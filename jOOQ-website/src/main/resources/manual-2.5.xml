<?xml version="1.0" encoding="UTF-8"?>
<manual>
	<section id="manual">
		<title>The jOOQ User Manual. Multiple Pages</title>
		<content>
			<h2 id="Overview"><a href="#Overview" name="Overview">#</a> Overview</h2>
			<p>This manual is divided into six main sections:</p>

			<ul>
				<li>
					<reference id="getting-started"/>
					<p>
						This section will get you started with jOOQ quickly. It contains
						simple explanations about what jOOQ is, what jOOQ isn't and how
						to set it up for the first time
					</p>
				</li>
				<li>
					<reference id="sql-building"/>
					<p>
						This section explains all about the jOOQ syntax used for building
						queries. It explains the central factories, the supported SQL
						statements and various other syntax elements
					</p>
				</li>
				<li>
					<reference id="code-generation"/>
					<p>
						This section explains how to configure and use the built-in source code
						generator
					</p>
				</li>
				<li>
					<reference id="sql-execution"/>
					<p>
						This section will get you through the specifics of what can be done
						with jOOQ at runtime, in order to execute queries, perform CRUD
						operations, import and export data, and hook into the jOOQ execution
						lifecycle for debugging
					</p>
				</li>
				<li>
					<reference id="tools"/>
					<p>
						This section is dedicated to tools that ship with jOOQ, such as the
						jOOQ console
					</p>
				</li>
				<li>
					<reference id="reference"/>
					<p>
						This section is a reference for elements in this manual
					</p>
				</li>
			</ul>
		</content>

		<sections>
			<section id="getting-started">
				<title>Getting started with jOOQ</title>
				<content>
				</content>

				<sections>
					<section id="the-manual">
					    <title>How to read this manual</title>
						<content>
						</content>
					</section>

					<section id="the-sample-database">
					    <title>The sample database used in this manual</title>
						<content>
							<h3>Example CREATE TABLE statements</h3>
							<p>
							For the examples in this manual, the same database will always be referred to. It essentially consists of these entities created using the Oracle dialect
							</p>
<sql>CREATE TABLE t_language (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  cd CHAR(2) NOT NULL,
  description VARCHAR2(50)
)

CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  first_name VARCHAR2(50),
  last_name VARCHAR2(50) NOT NULL,
  date_of_birth DATE,
  year_of_birth NUMBER(7)
)

CREATE TABLE t_book (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  author_id NUMBER(7) NOT NULL,
  title VARCHAR2(400) NOT NULL,
  published_in NUMBER(7) NOT NULL,
  language_id NUMBER(7) NOT NULL,
  FOREIGN KEY (AUTHOR_ID) REFERENCES T_AUTHOR(ID),
  FOREIGN KEY (LANGUAGE_ID) REFERENCES T_LANGUAGE(ID)
)

CREATE TABLE t_book_store (
  name VARCHAR2(400) NOT NULL UNIQUE
)

CREATE TABLE t_book_to_book_store (
  book_store_name VARCHAR2(400) NOT NULL,
  book_id INTEGER NOT NULL,
  stock INTEGER,
  PRIMARY KEY(book_store_name, book_id),
  CONSTRAINT b2bs_book_store_id
    FOREIGN KEY (book_store_name)
    REFERENCES t_book_store (name)
    ON DELETE CASCADE,
  CONSTRAINT b2bs_book_id
    FOREIGN KEY (book_id)
    REFERENCES t_book (id)
    ON DELETE CASCADE
)</sql>
							<p>
								More entities, types (e.g. UDT's, ARRAY types, ENUM types, etc), stored procedures and packages are introduced for specific examples
							</p>
						</content>
					</section>

					<section id="use-cases">
						<title>Different use cases for jOOQ</title>
						<content>
							<h3>jOOQ's original intent</h3>
							<p>
								jOOQ has originally been created as a library for complete abstraction of JDBC and all database interaction. Various best practices that are frequently encountered in pre-existing software products are applied to this library. This included:
							</p>
							<ul>
								<li>Typesafe database object referencing through generated schema, table, column, record, procedure, type, dao, pojo artefacts (see the chapter about <reference id="code-generation" title="code generation"/>)</li>
								<li>Typesafe SQL construction through a complete API modelling SQL as a domain specific language in Java (see the chapter about <reference id="dsl-and-non-dsl" title="the DSL API"/>)</li>
								<li>Convenient query execution through an improved API for result fetching (see the chapters about <reference id="fetching" title="the various types of data fetching"/>)</li>
								<li>SQL dialect abstraction and SQL clause simulation to improve cross-database compatibility and to enable missing features in simpler databases (see the chapter about <reference id="sql-dialects" title="SQL dialects"/>)</li>
								<li>SQL logging and debugging using jOOQ as an integral part of your development process (see the chapters about <reference id="logging" title="logging"/> and about the <reference id="jooq-console" title="jOOQ Console"/>)</li>
							</ul>
							<p>
								Effectively, jOOQ was originally designed to replace any other database abstraction framework short of the ones handling connection pooling and transaction management.
							</p>
							
							<h3>Use jOOQ the way you prefer</h3>
							<p>
								... but open source is community-driven. And the community has shown various ways of using jOOQ that diverge from its original intent. Some use cases encountered are:
							</p>
							<ul>
								<li>Using Hibernate for 70% of the queries (i.e. <reference id="crud-with-updatablerecords" title="CRUD"/>) and jOOQ for the remaining 30% where SQL is really needed</li>
								<li>Using jOOQ for SQL building and JDBC for SQL execution</li> 
								<li>Using jOOQ for SQL building and Spring Data for SQL execution</li>
								<li>Using jOOQ without the <reference id="code-generation" title="source code generator"/> to build the basis of a framework for dynamic SQL execution.</li> 
							</ul>
							
							<p>
								The following sections explain about various use cases for using jOOQ in your application.
							</p>
						</content>

						<sections>
							<section id="jooq-as-a-standalone-sql-builder">
								<title>jOOQ as a SQL builder</title>
								<content></content>
							</section>

							<section id="jooq-as-a-sql-builder-with-code-generation">
								<title>jOOQ as a SQL builder with code generation</title>
								<content></content>
							</section>

							<section id="jooq-as-a-sql-executor">
								<title>jOOQ as a SQL executor</title>
								<content></content>
							</section>

							<section id="jooq-for-crud">
								<title>jOOQ for CRUD</title>
								<content></content>
							</section>
						</sections>
					</section>

					<section id="tutorials">
						<title>Tutorials</title>
						<content>
							<h3>Follow these various tutorials to get you into jOOQ quickly</h3>
							<p>
								Don't have time to read the full manual? Here are a couple of tutorials that will get you into the most essential parts of jOOQ as quick as possible.
							</p>
						</content>

						<sections>
							<section id="jooq-in-7-steps">
								<title>jOOQ in 7 easy steps</title>
								<content>
									<h3>Download and run jOOQ in 7 easy steps</h3>
									<p>
										This manual section is intended for new users, in order to get a running application with jOOQ, quickly.
									</p>
								</content>
								
								<sections>
									<section id="jooq-in-7-steps-step1">
										<title>Step 1: Preparation</title>
										<content>
											<h3>Preparation: Download jOOQ and your SQL driver</h3>
											<p>
												If you haven't already downloaded them, download jOOQ:<br/>
												<a href="https://sourceforge.net/projects/jooq/files/Release/" title="jOOQ download">https://sourceforge.net/projects/jooq/files/Release/</a>
											</p>
											
											<p>
												Alternatively, you can create a Maven dependency:
											</p>
<xml><![CDATA[
<dependency>
  <groupId>org.jooq</groupId>
  <!-- artefacts are jooq, jooq-meta, jooq-codegen -->
  <artifactId>jooq</artifactId>
  <version>{jooq-version}</version>
</dependency>]]></xml>

											<p>
												For this example, we'll be using MySQL. If you haven't already downloaded MySQL Connector/J, download it here:<br/>
												<a href="http://dev.mysql.com/downloads/connector/j/" target="_blank" title="MySQL JDBC driver">http://dev.mysql.com/downloads/connector/j/</a>
											</p>

											<p>
												If you don't have a MySQL instance up and running yet, get <a href="http://www.apachefriends.org/en/xampp.html" title="XAMPP">XAMPP</a> now! XAMPP is a simple installation bundle for Apache, MySQL, PHP and Perl
											</p>
										</content>
									</section>
									
									<section id="jooq-in-7-steps-step2">
										<title>Step 2: Your database</title>
										<content>
											<h3>Create a SQL database and a table</h3>
											<p>
												We're going to create a database called "guestbook" and a corresponding "posts" table. Connect to MySQL via your command line client and type the following:
											</p>
											
<sql>
CREATE DATABASE guestbook;

CREATE TABLE `posts` (
  `id` bigint(20) NOT NULL,
  `body` varchar(255) DEFAULT NULL,
  `timestamp` datetime DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
);
</sql>
										</content>
									</section>
									
									<section id="jooq-in-7-steps-step3">
										<title>Step 3: Code generation</title>
										<content>
											<h3>Use jOOQ's code generator to generate classes from your guestbook database</h3>

											<p>
												In this step, we're going to use jOOQ's command line tools to generate classes that map to the Posts table we just created. More detailed information about how to set up the jOOQ code generator can be found here:<br/>
												<reference id="code-generation" title="jOOQ manual pages about setting up the code generator"/>
											</p>

											<p>
												The easiest way to generate a schema is to copy the jOOQ jar files (there should be 3) and the MySQL Connector jar file to a temporary directory. Then, create a guestbook.xml that looks like this:
											</p>
											
<xml><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<configuration xmlns="http://www.jooq.org/xsd/jooq-codegen-2.5.0.xsd">
  <!-- Configure the database connection here -->
  <jdbc>
    <driver>com.mysql.jdbc.Driver</driver>
    <url>jdbc:mysql://localhost:3306/guestbook</url>
    <user>root</user>
    <password></password>
  </jdbc>

  <generator>
    <!-- The default code generator. You can override this one, to generate your own code style
         Defaults to org.jooq.util.DefaultGenerator -->
    <name>org.jooq.util.DefaultGenerator</name>

    <database>
      <!-- The database type. The format here is:
           org.util.[database].[database]Database -->
      <name>org.jooq.util.mysql.MySQLDatabase</name>

      <!-- The database schema (or in the absence of schema support, in your RDBMS this
           can be the owner, user, database name) to be generated -->
      <inputSchema>guestbook</inputSchema>

      <!-- All elements that are generated from your schema (several Java regular expressions, separated by comma)
           Watch out for case-sensitivity. Depending on your database, this might be important! -->
      <includes>.*</includes>

      <!-- All elements that are excluded from your schema (several Java regular expressions, separated by comma).
              Excludes match before includes -->
      <excludes></excludes>
    </database>

    <target>
      <!-- The destination package of your generated classes (within the destination directory) -->
      <packageName>test.generated</packageName>

      <!-- The destination directory of your generated classes -->
      <directory>C:/workspace/MySQLTest/src</directory>
    </target>
  </generator>
</configuration>]]></xml>
											<p>
												Replace the username with whatever user has the appropriate privileges to query the database meta data. You'll also want to look at the other values and replace as necessary. Here are the two interesting properties:
											</p>
											<p>
												<code>generator.target.package</code> - set this to the parent package you want to create for the generated classes. The setting of <code>test.generated</code> will cause the <code>test.generated.Posts</code> and <code>test.generated.PostsRecord</code> to be created
											</p>
											<p>
												<code>generator.target.directory</code> - the directory to output to.
											</p>
											
											<p>
												Once you have the JAR files and guestbook.xml in your temp directory, type this (use colons instead of semi-colons on UNIX/Linux systems):
											</p>

<text>
java -classpath jooq-{jooq-version}.jar;jooq-meta-{jooq-version}.jar;jooq-codegen-{jooq-version}.jar;mysql-connector-java-5.1.18-bin.jar;. org.jooq.util.GenerationTool /guestbook.xml
</text>

											<p>
												Note the prefix slash before guestbook.xml. Even though it's in our working directory, we need to prepend a slash, as the configuration file is loaded from the classpath. Replace the filenames with your filenames. In this example, jOOQ {jooq-version} is being used. If everything has worked, you should see this in your console output:
											</p>
<text>
Nov 1, 2011 7:25:06 PM org.jooq.impl.JooqLogger info
INFO: Initialising properties  : /guestbook.xml
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Database parameters
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: ----------------------------------------------------------
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO:   dialect                : MYSQL
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO:   schema                 : guestbook
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO:   target dir             : /Users/jOOQ/Documents/workspace/MySQLTest/src
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO:   target package         : test.generated
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: ----------------------------------------------------------
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Emptying                 : /Users/jOOQ/workspace/MySQLTest/src/test/generated
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating classes in    : /Users/jOOQ/workspace/MySQLTest/src/test/generated
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating schema        : Guestbook.java
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating factory       : GuestbookFactory.java
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Schema generated         : Total: 122.18ms
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Sequences fetched        : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Masterdata tables fetched: 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Tables fetched           : 5 (5 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating tables        : /Users/jOOQ/workspace/MySQLTest/src/test/generated/tables
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: ARRAYs fetched           : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Enums fetched            : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: UDTs fetched             : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating table         : Posts.java
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Tables generated         : Total: 680.464ms, +558.284ms
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating Keys          : /Users/jOOQ/workspace/MySQLTest/src/test/generated/tables
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Keys generated           : Total: 718.621ms, +38.157ms
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Generating records       : /Users/jOOQ/workspace/MySQLTest/src/test/generated/tables/records
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Generating record        : PostsRecord.java
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Table records generated  : Total: 782.545ms, +63.924ms
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Routines fetched         : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Packages fetched         : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: GENERATION FINISHED!     : Total: 791.688ms, +9.143ms
</text>
										
										</content>
									</section>
									
									<section id="jooq-in-7-steps-step4">
										<title>Step 4: Connect to your database</title>
										<content>
											<h3>Write a main class and establish a MySQL connection</h3>
											<p>
												Let's just write a vanilla main class in the project containing the generated classes:
											</p>
<java><![CDATA[// For convenience, always static import your generated tables and
// jOOQ functions to decrease verbosity:
import static test.generated.Tables.*;
import static org.jooq.impl.Factory.*;

public class Main {
    public static void main(String[] args) {
        Connection conn = null;

        String userName = "root";
        String password = "";
        String url = "jdbc:mysql://localhost:3306/guestbook";

        try {
            Class.forName("com.mysql.jdbc.Driver").newInstance();
            conn = DriverManager.getConnection(url, userName, password);
        } catch (Exception e) {
            // For the sake of this tutorial, let's keep exception handling simple
            e.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ignore) {
                }
            }
        }
    }
}]]></java>

											<p>
												This is pretty standard code for establishing a MySQL connection.
											</p>
										</content>
									</section>
									
									<section id="jooq-in-7-steps-step5">
										<title>Step 5: Querying</title>
										<content>
											<h3>Write a query using jOOQ's DSL API</h3>

											<p>
												Let's add a simple query:
											</p>
											
<java><![CDATA[Factory create = new Factory(conn, SQLDialect.MYSQL);
Result<Record> result = create.select().from(POSTS).fetch();]]></java>

											<p>
												First get an instance of <code>Factory</code> so we can write a simple <code>SELECT</code> query. We pass an instance of the MySQL connection to <code>Factory</code>. Note that the factory doesn't close the connection. We'll have to do that ourselves.
											</p>
											<p>
												We then use jOOQ's DSL to return an instance of Result. We'll be using this result in the next step.
											</p>
										</content>
									</section>
									
									<section id="jooq-in-7-steps-step6">
										<title>Step 6: Iterating</title>
										<content>
											<h3>Iterate over the results of the previously executed query</h3>
											<p>
												After the line where we retrieve the results, let's iterate over the results and print out the data:
											</p>

<java><![CDATA[for (Record r : result) {
    Long id = r.getValue(POSTS.ID);
    String title = r.getValue(POSTS.TITLE);
    String description = r.getValue(POSTS.BODY);

    System.out.println("ID: " + id + " title: " + title + " desciption: " + description);
}]]></java>

											<p>
												The full program should now look like this:
											</p>
											
<java><![CDATA[package test;

// For convenience, always static import your generated tables and
// jOOQ functions to decrease verbosity:
import static test.generated.Tables.*;
import static org.jooq.impl.Factory.*;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

import org.jooq.Record;
import org.jooq.Result;

import test.generated.GuestbookFactory;
import test.generated.tables.Posts;

public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) {
        Connection conn = null;

        String userName = "root";
        String password = "";
        String url = "jdbc:mysql://localhost:3306/guestbook";

        try {
            Class.forName("com.mysql.jdbc.Driver").newInstance();
            conn = DriverManager.getConnection(url, userName, password);

            GuestbookFactory create = new GuestbookFactory(conn);
            Result&lt;Record&gt; result = create.select().from(POSTS).fetch();

            for (Record r : result) {
                Long id = r.getValue(POSTS.ID);
                String title = r.getValue(POSTS.TITLE);
                String description = r.getValue(POSTS.BODY);

                System.out.println("ID: " + id + " title: " + title + " desciption: " + description);
            }
        } catch (Exception e) {
            // For the sake of this tutorial, let's keep exception handling simple
            e.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ignore) {
                }
            }
        }
    }
}]]></java>
										</content>
									</section>
									
									<section id="jooq-in-7-steps-step7">
										<title>Step 7: Explore!</title>
										<content>
											<h3>You're all set. Explore the rest of the library!</h3>
											<p>
												jOOQ has grown to be a comprehensive SQL library. For more information, please consider the manual:<br/>
												<a href="http://www.jooq.org/manual/" title="jOOQ Manual">http://www.jooq.org/manual/</a>
											</p>
											<p>
												... explore the Javadoc:<br/>
												<a href="http://www.jooq.org/javadoc/latest/" title="jOOQ Javadoc">http://www.jooq.org/javadoc/latest/</a>
											</p>
											<p>
												... or join the news group:<br/>
												<a href="https://groups.google.com/forum/#!forum/jooq-user" title="jOOQ news group">https://groups.google.com/forum/#!forum/jooq-user</a>
											</p>
											<p>
											    This tutorial is the courtesy of Ikai Lan. See the original source here:<br/>
											    <a href="http://ikaisays.com/2011/11/01/getting-started-with-jooq-a-tutorial/" target="_blank" title="Ikai Lan's jOOQ tutorial">http://ikaisays.com/2011/11/01/getting-started-with-jooq-a-tutorial/</a>
											</p>
										</content>
									</section>
								</sections>
							</section>

							<section id="jooq-in-modern-ides">
								<title>Using jOOQ in modern IDEs</title>
								<content></content>
							</section>

							<section id="jooq-with-spring">
								<title>Using jOOQ with Spring</title>
								<content></content>
							</section>

							<section id="a-simple-web-application">
								<title>A simple web application with jOOQ</title>
								<content></content>
							</section>
						</sections>
					</section>
				</sections>
			</section>

			<section id="sql-building">
				<title>SQL building</title>
				<content>
					<h3>Overview</h3>
					<p>
					    SQL is a declarative language that is hard to integrate into procedural, object-oriented, functional or any other type of programming languages. jOOQ's philosophy is to give SQL the credit it deserves and integrate SQL itself as an <a href="http://en.wikipedia.org/wiki/Domain_Specific_Language">"internal domain specific language"</a> directly into Java.
					</p>
					<p>
						With this philosophy in mind, SQL building is the main feature of jOOQ. All other features (such as <reference id="sql-execution"/> and <reference id="code-generation"/>) are mere convenience built on top of jOOQ's SQL building capabilities.
					</p>
					<p>
						This section explains all about the various syntax elements involved with jOOQ's SQL building capabilities. For a complete overview of all syntax elements, please refer to the manual's section about <reference id="reference-bnf-notation"/>
					</p>
				</content>

				<sections>
					<section id="factory">
						<title>The Factory class</title>
						<content>
							<h3>The Factory and the jOOQ API</h3>
							<p>
								jOOQ exposes a lot of interfaces and hides most implementation facts from client code. The reasons for this are:
							</p>
							<ul>
								<li>Interface-driven design. This allows for modelling queries in a fluent API most efficiently</li>
								<li>Reduction of complexity for client code.</li>
								<li>API guarantee. You only depend on the exposed interfaces, not concrete (potentially dialect-specific) implementations.</li>
							</ul>
							<p>
								The <reference class="org.jooq.impl.Factory"/> class is the main class from where you will create all jOOQ objects.	The Factory serves two types of purposes:
							</p>
							<ol>
								<li>It serves as a static factory for <reference id="table-expressions" title="table expressions"/>, <reference id="column-expressions" title="column expressions"/> (or "fields"), <reference id="conditional-expressions" title="conditional expressions"/> and many other <reference id="queryparts" title="QueryParts"/>.</li>
								<li>It implements <reference class="org.jooq.Configuration"/>, an object that configures jOOQ's behaviour when executing queries (see <reference id="sql-execution"/> for more details). Factories allow for creating <reference id="sql-statements" title="SQL statements"/> that are already "configured" and ready for execution.</li>
							</ol>

							<h3>The static Factory API</h3>
							<p>
								With jOOQ 2.0, static factory methods have been introduced in order to make client code look more like SQL. Ideally, when working with jOOQ, you will simply static import all methods from the Factory class:
							</p>
							<java>import static org.jooq.impl.Factory.*;</java>
							<p>
							    Note, that when working with Eclipse, you could also add the Factory to your favourites. This will allow to access functions even more fluently:
							</p>
<java>concat(trim(FIRST_NAME), trim(LAST_NAME));
// ... which is in fact the same as:
Factory.concat(Factory.trim(FIRST_NAME), Factory.trim(LAST_NAME));</java>

							<h3>The Factory as a Configuration object</h3>
							<p>
							    As any Configuration object, a Factory can be supplied with these objects:
							</p>
							<ul>
								<li><reference class="org.jooq.SQLDialect"/> : The dialect of your database. This may be any of the currently supported database types (see <reference id="sql-dialects"/> for more details)</li>
								<li><reference class="java.sql.Connection"/> : An optional JDBC Connection that will be re-used for the whole lifecycle of your Factory (see <reference id="connection-vs-datasource"/> for more details)</li>
    							<li><reference class="java.sql.DataSource"/> : An optional JDBC DataSource that will be re-used for the whole lifecycle of your Factory. If you prefer using DataSources over Connections, jOOQ will internally fetch new Connections from your DataSource, conveniently closing them again after query execution. This is particularly useful in J2EE or Spring contexts (see <reference id="connection-vs-datasource"/> for more details)</li>
    							<li><reference class="org.jooq.conf.Settings"/> : An optional runtime configuration (see <reference id="custom-settings"/> for more details)</li>
							</ul>
							<p>
								As a Configuration object, a Factory can construct <reference id="sql-statements" title="statements"/>, for later <reference id="sql-execution" title="execution"/>. An example is given here:
							</p>
<java><![CDATA[// The Factory is "configured" with a Connection and a SQLDialect
Factory create = new Factory(connection, dialect);

// This select statement contains an internal reference to the Factory:
Select<?> select = create.selectOne();

// Using the internally referenced Factory, the select statement can now be executed:
Result<?> result = select.fetch();]]></java>
						</content>

						<sections>
							<section id="sql-dialects">
								<title>SQL Dialect</title>
								<content>
									<h3>The SQL dialect corresponding to your database</h3>
									<p>
										While jOOQ tries to represent the SQL standard as much as possible, many features are vendor-specific to a given database and to its "SQL dialect". jOOQ models this using the <reference class="org.jooq.SQLDialect"/> enum type.
									</p>
									<p>
										The SQL dialect is one of the main attributes of a <reference id="factory" title="Factory"/>. Queries created from such factories will assume dialect-specific behaviour when <reference id="sql-rendering" title="rendering SQL"/> and <reference id="variable-binding" title="binding bind values"/>.
									</p>
									<p>
										Some parts of the jOOQ API are officially supported only by a given subset of the supported SQL dialects. For instance, the <reference id="connect-by-clause" title="Oracle CONNECT BY clause"/>, which is supported by the Oracle and CUBRID databases, is annotated with a <reference class="org.jooq.Support"/> annotation, as such:
									</p>
<java><![CDATA[/**
 * Add an Oracle-specific <code>CONNECT BY</code> clause to the query
 */
@Support({ CUBRID, ORACLE })
SelectConnectByConditionStep connectBy(Condition condition);]]></java>
									<p>
									    jOOQ API methods which are not annotated with the <reference class="org.jooq.Support"/> annotation, or which are annotated with the Support annotation, but without any SQL dialects can be safely used in all SQL dialects. An example for this is the <reference id="select-statement" title="SELECT statement"/> factory method:
									</p>
<java><![CDATA[/**
 * Create a new DSL select statement.
 */
@Support
SelectSelectStep select(Field<?>... fields);]]></java>

									<h3>jOOQ's SQL clause simulation capabilities</h3>
									<p>
										The aforementioned Support annotation does not only designate, which databases natively support a feature. It also indicates that a feature is simulated by jOOQ for some databases lacking this feature. An example of this is the <reference id="distinct-predicate" title="DISTINCT predicate"/>, a predicate syntax defined by SQL:1999 and implemented only by H2, HSQLDB, and Postgres:
									</p>

<sql><![CDATA[A IS DISTINCT FROM B]]></sql>

									<p>
										Nevertheless, the <code>IS DISTINCT FROM</code> predicate is supported in all dialects, as its semantics can be expressed with an equivalent <reference id="case-expressions" title="CASE expression"/>. For more details, see the manual's section about the <reference id="distinct-predicate" title="DISTINCT predicate"/>.
									</p>
									
									<h3>jOOQ and the Oracle SQL dialect</h3>
									<p>
										Oracle SQL is much more expressive than many other SQL dialects. It features many unique keywords, clauses and functions that are out of scope for the SQL standard. Some examples for this are
									</p>
									<ul>
										<li>The <reference id="connect-by-clause" title="CONNECT BY clause"/>, for hierarchical queries</li>
										<li>The <reference id="pivot-tables" title="PIVOT"/> keyword for creating PIVOT tables</li>
										<li><reference id="oracle-packages" title="Packages"/>, <reference id="oracle-member-procedures" title="object-oriented user-defined types, member procedures"/> as described in the section about <reference id="stored-procedures" title="stored procedures and functions"/></li>
										<li>Advanced analytical functions as described in the section about <reference id="window-functions" title="window functions"/></li>
									</ul>

									<p>
										jOOQ has a historic affinity to Oracle's SQL extensions. If something is supported in Oracle SQL, it has a high probability of making it into the jOOQ API
									</p>
								</content>
							</section>

							<section id="connection-vs-datasource">
								<title>Connection vs. DataSource</title>
								<content>
									<h3>Interact with JDBC Connections</h3>
									<p>
										While you can use jOOQ for <reference id="sql-building" title="SQL building"/> only, you can also run queries against a JDBC <reference class="java.sql.Connection"/>. Internally, jOOQ creates <reference class="java.sql.Statement"/> or <reference class="java.sql.PreparedStatement"/> objects from such a Connection, in order to execute statements. The normal operation mode is to provide a <reference id="factory" title="Factory"/> with a JDBC Connection, whose lifecycle you will control yourself. This means that jOOQ will not actively close connections, rollback or commit transactions.
									</p>
									<h3>Interact with JDBC DataSources</h3>
									<p>
										If you're in a J2EE or Spring context, however, you may wish to use a <reference class="javax.sql.DataSource"/> instead. Currently, Connections obtained from such a DataSource will be closed after query execution by jOOQ. The semantics of such a close operation should be the returning of the connection into a connection pool, not the actual closing of the underlying physical connection. Typically, this makes sense in an environment using distributed JTA transactions. An example of using DataSources with jOOQ can be seen in the tutorial section about <reference id="jooq-with-spring" title="using jOOQ with Spring"/>.
									</p>
								</content>
							</section>

							<section id="custom-settings">
								<title>Custom Settings</title>
								<content>
									<h3>Factory settings</h3>
									<p>
										The jOOQ Factory allows for some optional configuration elements to be used by advanced users. The <reference class="org.jooq.conf.Settings" /> class is a JAXB-annotated type, that can be provided to a Factory in several ways:
									</p>
									<ul>
										<li>In the constructor. This will override default settings below</li>
										<li>From a location specified by a JVM parameter: -Dorg.jooq.settings</li>
										<li>From the classpath at /jooq-settings.xml</li>
										<li>From the settings defaults, as specified in <a href="http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd" title="The jOOQ Runtime configuration XSD">http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd</a></li>
									</ul>
									<h3>Example</h3>
									<p>
										For example, if you want to indicate to jOOQ, that it should inline all bind variables, and execute static <reference class="java.sql.Statement"/> instead of binding its variables to <reference class="java.sql.PreparedStatement"/>, you can do so by using the following Factory:
									</p>
<java><![CDATA[Settings settings = new Settings();
settings.setStatementType(StatementType.STATIC_STATEMENT);
Factory create = new Factory(connection, dialect, settings);]]></java>
									<p>
										Subsequent sections of the manual contain some more in-depth explanations about these settings:
									</p>
									<ul>
										<li>
		     								<reference id="schema-mapping" title="Runtime schema and table mapping"/>
		   								</li>
		     							<li>
		     								<reference id="execute-listeners" title="Execute listeners and SQL tracing"/>
		     							</li>
		     							<li>
		     								<reference id="optimistic-locking" title="Execute CRUD with optimistic locking enabled"/>
		     							</li>
		     							<li>
		     								<reference id="logging" title="Enabling DEBUG logging of all executed SQL"/>
		     							</li>
		   							</ul>
		   							<p>
										Please refer to the jOOQ runtime configuration XSD for more details:<br/>
										<a href="http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd" title="The jOOQ Runtime configuration XSD">http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd</a>
									</p>
								</content>
							</section>

							<section id="factory-subclasses">
								<title>Factory subclasses</title>
								<content>
									<p>
										There are a couple of subclasses for the general Factory. Each SQL dialect has its own dialect-specific factory. For instance, if you're only using the MySQL dialect, you can choose to create a new Factory using any of the following types:
									</p>
<java>// A general, dialect-unspecific factory
Factory create = new Factory(connection, SQLDialect.MYSQL);

// A MySQL-specific factory
MySQLFactory create = new MySQLFactory(connection);</java>
									<p>
										The advantage of using a dialect-specific Factory lies in the fact,	that you have access to more proprietary RDMBS functionality. This may include:
									</p>
									<ul>
		    							<li>MySQL's encryption functions</li>
		    							<li>PL/SQL constructs, pgplsql, or any other dialect's ROUTINE-language (maybe in the future)</li>
									</ul>
									<p>
										Another type of Factory subclasses are each generated schema's factories. If you generate your schema TEST, then you will have access to a TestFactory. By default, such a schema-specific Factory will not render the schema name.
									</p>
								</content>
							</section>
						</sections>
					</section>

					<section id="sql-statements">
						<title>SQL Statements</title>
						<content>
							<h3>SQL statements as understood by jOOQ</h3>
							<p>
								jOOQ currently supports 6 types of SQL statements. All of these statements are constructed from a Factory instance with an optional <reference id="connection-vs-datasource" title="JDBC Connection or DataSource"/>. If supplied with a Connection or DataSource, they can be executed. Depending on the <reference id="query-vs-resultquery" title="query type"/>, executed queries can return results.
							</p>
						</content>

						<sections>
							<section id="dsl-and-non-dsl">
								<title>jOOQ's DSL and non-DSL API</title>
								<content>
									<h3>The power of jOOQ's DSL API</h3>
									<p>
										jOOQ ships with its own DSL (or	<a href="http://en.wikipedia.org/wiki/Domain-specific_language" title="Domain Specific Language">Domain Specific Language</a>) that	simulates SQL in Java. This means, that you can	write SQL statements almost as if Java natively supported it, just like .NET's C# does with <a href="http://msdn.microsoft.com/en-us/library/bb425822.aspx">LINQ to SQL.</a>
									</p>
									<p>
										Here is an example to illustrate what that means:
									</p>
<code-pair><sql><![CDATA[-- Select all books by authors born after 1920,
-- named "Paulo" from a catalogue:
SELECT *
  FROM t_author a
  JOIN t_book b ON a.id = b.author_id
 WHERE a.year_of_birth > 1920
   AND a.first_name = 'Paulo'
 ORDER BY b.title]]></sql>
<java><![CDATA[Result<Record> result =
create.select()
      .from(T_AUTHOR.as("a"))
      .join(T_BOOK.as("b")).on(a.ID.equal(b.AUTHOR_ID))
      .where(a.YEAR_OF_BIRTH.greaterThan(1920)
      .and(a.FIRST_NAME.equal("Paulo")))
      .orderBy(b.TITLE)
      .fetch();]]></java></code-pair>

									<p>
										We'll see how the aliasing works later in the section about <reference id="aliasing" title="aliasing"/>
									</p>

									<h3>jOOQ as an internal domain specific language in Java</h3>
									<p>
										Many other frameworks have similar APIs with similar feature sets. Yet, what makes jOOQ special is its informal <reference id="reference-bnf-notation" title="BNF notation"/> modelling a unified SQL dialect suitable for many vendor-specific dialects, and implementing that BNF notation as a hierarchy of interfaces in Java. This concept is extremely powerful, when <reference id="jooq-in-modern-ides" title="using jOOQ in modern IDEs" /> with syntax completion. Not only can you code much faster, your SQL code will be compile-checked to a certain extent. An example of a DSL query equivalent to the previous one is given here:
									</p>
<java><![CDATA[Factory create = new Factory(connection, dialect);
Result<?> result = create.select()
                         .from(AUTHOR)
                         .join(BOOK).on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
                         .fetch();]]></java>

                         			<p>
                         				Unlike other, simpler frameworks that use <a href="http://en.wikipedia.org/wiki/Fluent_interface">"fluent APIs"</a> or <a href="http://en.wikipedia.org/wiki/Method_chaining">"method chaining"</a>, jOOQ's BNF-based interface hierarchy will not allow bad query syntax. The following will not compile, for instance:
                         			</p>
<java><![CDATA[Factory create = new Factory(connection, dialect);
Result<?> result = create.select()
                         .join(BOOK).on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
                      //  ^^^^ "join" is not possible here
                         .from(AUTHOR)
                         .fetch();

Result<?> result = create.select()
                         .from(AUTHOR)
                         .join(BOOK)
                         .fetch();
                      //  ^^^^^ "on" is missing here

Result<?> result = create.select(rowNumber())
                      //         ^^^^^^^^^ "over()" is missing here
                         .from(AUTHOR)
                         .fetch();]]></java>

									<h3>History of SQL building and incremental query building</h3>
									<p>
										Historically, jOOQ started out as an object-oriented SQL builder library like any other. This meant that all queries and their syntactic components were modeled as so-called <reference id="queryparts" title="QueryParts"/>, which delegate <reference id="sql-rendering" title="SQL rendering"/> and <reference id="variable-binding" title="variable binding"/> to child components. This part of the API will be referred to as the non-DSL API, which is still maintained and used internally by jOOQ for incremental query building. An example of incremental query building is given here:
									</p>
<java><![CDATA[Factory create = new Factory(connection, dialect);
SelectQuery query = create.selectQuery();
query.addFrom(AUTHOR);

// Join books only under certain circumstances
if (join) {
    query.addJoin(BOOK, BOOK.AUTHOR_ID.equal(AUTHOR.ID));
}

Result<?> result = query.fetch();]]></java>

									<p>
										This query is equivalent to the one shown before using the DSL syntax. In fact, internally, the DSL API constructs precisely this QueryObject. Note, that you can always access the SelectQuery object to switch between DSL and non-DSL APIs:
									</p>

<java><![CDATA[Factory create = new Factory(connection, dialect);
SelectFinalStep select = create.select().from(AUTHOR);

// Add the JOIN clause on the internal QueryObject representation
SelectQuery query = select.getQuery();
query.addJoin(BOOK, BOOK.AUTHOR_ID.equal(AUTHOR.ID));]]></java>
								</content>
							</section>

							<section id="select-statement">
								<title>The SELECT statement</title>
								<content>
									<h3>SELECT from ad-hoc table expressions</h3>
									<p>
										When you don't just perform <reference id="crud-with-updatablerecords" title="CRUD"/> (i.e. SELECT * FROM your_table WHERE ID = ?), you're usually generating new record types using custom projections. With jOOQ, this is as intuitive, as if using SQL directly. A more or less complete example of the "standard" SQL syntax, plus some extensions, is provided by a query like this:
									</p>
<code-pair>
<sql>-- get all authors' first and last names, and the number
-- of books they've written in German, if they have written
-- more than five books in German in the last three years
-- (from 2011), and sort those authors by last names
-- limiting results to the second and third row, locking
-- the rows for a subsequent update... whew!

  SELECT AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, COUNT(*)
    FROM AUTHOR
    JOIN BOOK ON AUTHOR.ID = BOOK.AUTHOR_ID
   WHERE BOOK.LANGUAGE = 'DE'
     AND BOOK.PUBLISHED > '2008-01-01'
GROUP BY AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME
  HAVING COUNT(*) > 5
ORDER BY AUTHOR.LAST_NAME ASC NULLS FIRST
   LIMIT 2
  OFFSET 1
     FOR UPDATE</sql>
<java>





Factory create = new Factory(connection, dialect);

create.select(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, count())
      .from(AUTHOR)
      .join(BOOK).on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
      .where(BOOK.LANGUAGE.equal("DE"))
      .and(BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(AUTHOR.LAST_NAME.asc().nullsFirst())
      .limit(1)
      .offset(2)
      .forUpdate();</java>
</code-pair>

									<p>
										Details about the various clauses of this query will be provided in subsequent sections
									</p>

									<h3>SELECT from single physical tables</h3>
									<p>
										A very similar, but limited API is available, if you want to select from single physical tables in order to retrieve <reference id="crud-with-updatablerecords" title="TableRecords or even UpdatableRecords"/>. The decision, which type of select to create is already made at the very first step, when you create the SELECT statement with the Factory:
									</p>

<java><![CDATA[public <R extends Record> SimpleSelectWhereStep<R> selectFrom(Table<R> table);]]></java>
									<p>
										As you can see, there is no way to further restrict/project the selected fields. This just selects all known TableFields in the supplied Table, and it also binds &lt;R extends Record&gt; to your Table's associated Record. An example of such a Query would then be:
									</p>
<java><![CDATA[Book book = create.selectFrom(BOOK)
                  .where(BOOK.LANGUAGE.equal("DE"))
                  .orderBy(BOOK.TITLE)
                  .fetchAny();]]></java>

                   					<p>
                   						The simple SELECT API is limited in the way that it does not support any of these clauses:
                   					</p>
                   					<ul>
                   						<li><reference id="select-clause"/></li>
                   						<li><reference id="join-clause"/></li>
                   						<li><reference id="group-by-clause"/></li>
                   						<li><reference id="having-clause"/></li>
                   					</ul>
                   					<p>
                   						In most parts of this manual, it is assumed that you do not use the simple SELECT API.
                   					</p>
								</content>

								<sections>
									<section id="select-clause">
										<title>The SELECT clause</title>
										<content>
											<h3>The SELECT clause, projecting your own record types</h3>
											<p>
												The SELECT clause lets you project your own record types, referencing table fields, functions, arithmetic expressions, etc. The Factory provides several methods for expressing a SELECT clause:
											</p>

<code-pair><java><![CDATA[// You can provide a varargs Fields list to the SELECT clause:
Select<?> select1 = create.select(BOOK.ID, BOOK.TITLE);
Select<?> select2 = create.select(BOOK.ID, trim(BOOK.TITLE));]]></java>
<sql><![CDATA[

SELECT BOOK.ID, BOOK.TITLE
SELECT BOOK.ID, TRIM(BOOK.TITLE)
]]></sql></code-pair>

											<p>
												Some commonly used projections can be easily created using convenience methods:
											</p>

<code-pair><java><![CDATA[// Select commonly used values
Select<?> select1 = create.selectCount();
Select<?> select2 = create.selectZero();
Select<?> select2 = create.selectOne();]]></java>
<sql><![CDATA[

SELECT COUNT(*)
SELECT 0 -- Not a bind variable
SELECT 1 -- Not a bind variable
]]></sql></code-pair>

											<p>
												See more details about functions and expressions in the manual's section about <reference id="column-expressions"/>
											</p>

											<h3>The SELECT DISTINCT clause</h3>
											<p>
												The DISTINCT keyword can be included in the method name, constructing a SELECT clause
											</p>

<code-pair><java><![CDATA[Select<?> select1 = create.selectDistinct(BOOK.TITLE);]]></java>
<sql><![CDATA[SELECT DISTINCT BOOK.TITLE]]></sql></code-pair>
										</content>
									</section>

									<section id="from-clause">
										<title>The FROM clause</title>
										<content>
											<h3>The FROM clause, allowing to specify a list of table expressions</h3>
											<p>
												The SQL FROM clause allows for specifying any number of <reference id="table-expressions" title="table expressions"/> to select data from. The following are examples of how to form normal FROM clauses:
											</p>

<code-pair>
	<sql><![CDATA[SELECT 1 FROM BOOK
SELECT 1 FROM BOOK, AUTHOR
SELECT 1 FROM BOOK "b", AUTHOR "a"]]></sql>
	<java><![CDATA[create.selectOne().from(BOOK);
create.selectOne().from(BOOK, AUTHOR);
create.selectOne().from(BOOK.as("b"), AUTHOR.as("a"));]]></java>
</code-pair>

											<p>
												Read more about aliasing in the manual's section about <reference id="aliasing" title="aliasing"/>.
											</p>

											<h3>Selecting FROM DUAL with jOOQ</h3>
											<p>
												In many SQL dialects, FROM is a mandatory clause, in some it isn't. jOOQ allows you to omit the FROM clause, returning just one record. An example:
											</p>

<code-pair>
	<sql><![CDATA[SELECT 1 FROM DUAL
SELECT 1]]></sql>
	<java><![CDATA[new Factory(SQLDialect.ORACLE).selectOne().getSQL();
new Factory(SQLDialect.POSTGRES).selectOne().getSQL();]]></java>
</code-pair>

											<p>
												Read more about dual or dummy tables in the manual's section about <reference id="dual" title="the DUAL table"/>. The following are examples of how to form normal FROM clauses:
											</p>
										</content>
									</section>

									<section id="join-clause">
										<title>The JOIN clause</title>
										<content>
											<h3>Complex table expressions using the JOIN clause</h3>
											<p>
												jOOQ supports many different types of standard SQL JOIN operations:
											</p>
											<ul>
												<li>[ INNER ] JOIN</li>
												<li>LEFT [ OUTER ] JOIN</li>
												<li>RIGHT [ OUTER ] JOIN</li>
												<li>FULL OUTER JOIN</li>
												<li>CROSS JOIN</li>
												<li>NATURAL JOIN</li>
												<li>NATURAL LEFT [ OUTER ] JOIN</li>
												<li>NATURAL RIGHT [ OUTER ] JOIN</li>
											</ul>

											<p>
												All of these JOIN methods can be called on <reference class="org.jooq.Table"/> types, or directly after the FROM clause for convenience. The following example joins AUTHOR and BOOK
											</p>

<java><![CDATA[Factory create = new Factory(connection, dialect);

// Call "join" directly on the AUTHOR table
Result<?> result = create.select()
                         .from(AUTHOR.join(BOOK)
                                     .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID)))
                         .fetch();

// Call "join" on the type returned by "from"
Result<?> result = create.select()
                         .from(AUTHOR)
                         .join(BOOK)
                         .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
                         .fetch();]]></java>

											<p>
												The two syntaxes will produce the same SQL statement. However, calling "join" on <reference class="org.jooq.Table"/> objects allows for more powerful, nested JOIN expressions (if you can handle the parentheses):
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM AUTHOR
LEFT OUTER JOIN (
  BOOK JOIN BOOK_TO_BOOK_STORE
       ON BOOK_TO_BOOK_STORE.BOOK_ID = BOOK.ID
)
ON BOOK.AUTHOR_ID = AUTHOR.ID]]></sql>
<java><![CDATA[// Nest joins and provide JOIN conditions only at the end
create.select()
      .from(AUTHOR
      .leftOuterJoin(BOOK
        .join(BOOK_TO_BOOK_STORE)
        .on(BOOK_TO_BOOK_STORE.BOOK_ID.equal(BOOK.ID)))
      .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID)));]]></java></code-pair>

      										<ul>
      											<li>See the section about <reference id="conditional-expressions" title="conditional expressions"/> to learn more about the many ways to create <reference class="org.jooq.Condition"/> objects in jOOQ.</li>
      											<li>See the section about <reference id="table-expressions" title="table expressions"/> to learn about the various ways of referencing <reference class="org.jooq.Table"/> objects in jOOQ</li>
      										</ul>

											<h3>JOIN ON KEY, convenience provided by jOOQ</h3>
											<p>
												Surprisingly, SQL does not allow to formally JOIN on well-known foreign key relationship information. Naturally, when you join BOOK to AUTHOR, you will want to do that based on the BOOK.AUTHOR_ID foreign key to AUTHOR.ID primary key relation. Not being able to do this in SQL leads to a lot of repetitive code, re-writing the same JOIN predicate again and again - especially, when your foreign keys contain more than one column. With jOOQ, when you use <reference id="code-generation" title="code generation"/>, you can use foreign key constraint information in JOIN expressions as such:
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM AUTHOR
JOIN BOOK ON BOOK.AUTHOR_ID = AUTHOR.ID]]></sql>
<java><![CDATA[create.select()
      .from(AUTHOR)
      .join(BOOK).onKey();]]></java></code-pair>

      										<p>
      											In case of ambiguity, you can also supply field references for your foreign keys, or the generated foreign key reference to the onKey() method.
      										</p>

											<h3>The JOIN USING syntax</h3>
											<p>
												Most often, you will provide jOOQ with JOIN conditions in the JOIN .. ON clause. SQL supports a different means of specifying how two tables are to be joined. This is the JOIN .. USING clause. Instead of a condition, you supply a set of fields whose names are common to both tables to the left and right of a JOIN operation. This can be useful when your database schema has a high degree of <a href="http://en.wikipedia.org/wiki/Database_normalization">relational normalisation</a>. An example:
											</p>

<code-pair>
<sql><![CDATA[-- Assuming that both tables contain AUTHOR_ID columns
SELECT *
FROM AUTHOR
JOIN BOOK USING (AUTHOR_ID)]]></sql>
<java><![CDATA[

create.select()
      .from(AUTHOR)
      .join(BOOK).using(AUTHOR.AUTHOR_ID);]]></java></code-pair>

											<p>
												In schemas with high degrees of normalisation, you may also choose to use NATURAL JOIN, which takes no JOIN arguments as it joins using all fields that are common to the table expressions to the left and to the right of the JOIN operator. An example:
											</p>

<code-pair>
<sql><![CDATA[-- Assuming that both tables contain AUTHOR_ID columns
SELECT *
FROM AUTHOR
NATURAL JOIN BOOK]]></sql>
<java><![CDATA[

create.select()
      .from(AUTHOR)
      .naturalJoin(BOOK);]]></java></code-pair>

											<h3>Oracle's partitioned OUTER JOIN</h3>
											<p>
												Oracle SQL ships with a special syntax available for OUTER JOIN clauses. According to the <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_10002.htm#i2196190">Oracle documentation about partitioned outer joins</a> this can be used to fill gaps for simplified analytical calculations. jOOQ only supports putting the PARTITION BY clause to the right of the OUTER JOIN clause. The following example will create at least one record per AUTHOR and per existing value in BOOK.PUBLISHED_IN, regardless if an AUTHOR has actually published a book in that year.
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM AUTHOR
LEFT OUTER JOIN BOOK
PARTITION BY (PUBLISHED_IN)
ON BOOK.AUTHOR_ID = AUTHOR.ID]]></sql>
<java><![CDATA[create.select()
      .from(AUTHOR)
      .leftOuterJoin(BOOK)
      .partitionBy(BOOK.PUBLISHED_IN)
      .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID));]]></java></code-pair>

										</content>
									</section>

									<section id="where-clause">
										<title>The WHERE clause</title>
										<content>
											<h3>Apply filtering predicates in the WHERE clause</h3>
											<p>
												The WHERE clause can be used for JOIN or filter predicates, in order to restrict the data returned by the <reference id="table-expressions" title="table expressions"/> supplied to the previously specified <reference id="from-clause" title="from clause"/> and <reference id="join-clause" title="join clause"/>. Here is an example:
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE AUTHOR_ID = 1
AND TITLE = '1984']]></sql>
<java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.AUTHOR_ID.equal(1))
      .and(BOOK.TITLE.equal("1984"));]]></java></code-pair>

											<p>
												The above syntax is convenience provided by jOOQ, allowing you to connect the <reference class="org.jooq.Condition"/> supplied in the WHERE clause with another condition using an AND operator. You can of course also create a more complex condition and supply that to the WHERE clause directly (observe the different placing of parentheses). The results will be the same:
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE AUTHOR_ID = 1
AND TITLE = '1984']]></sql>
<java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.AUTHOR_ID.equal(1).and(
             BOOK.TITLE.equal("1984")));]]></java></code-pair>

											<p>
												You will find more information about creating <reference id="conditional-expressions" title="conditional expressions"/> later in the manual.
											</p>
										</content>
									</section>

									<section id="connect-by-clause">
										<title>The CONNECT BY clause</title>
										<content>
											<h3>Oracle's syntax for creating hierarchical queries</h3>
											<p>
												The Oracle database knows a very succinct syntax for creating hierarchical queries: the CONNECT BY clause, which is fully supported by jOOQ, including all related functions and pseudo-columns. A more or less formal definition of this clause is given here:
											</p>
<sql>--   SELECT ..
--     FROM ..
--    WHERE ..
 CONNECT BY [NOCYCLE] condition [AND condition, ...] [START WITH condition]
-- GROUP BY ..</sql>

											<p>
												An example for an iterative query, iterating through values between 1 and 5 is this:
											</p>

<code-pair>
<sql><![CDATA[SELECT LEVEL
FROM DUAL
CONNECT BY LEVEL <= 5]]></sql>
<java><![CDATA[// Get a table with elements 1, 2, 3, 4, 5
create.select(level())
      .connectBy(level().lessOrEqual(5));]]></java></code-pair>

											<p>
												Here's a more complex example where you can recursively fetch directories in your database, and concatenate them to a path:
											</p>
<code-pair>
<sql><![CDATA[SELECT SUBSTR(SYS_CONNECT_BY_PATH(DIRECTORY.NAME, '/'), 2)
FROM DIRECTORY
CONNECT BY PRIOR DIRECTORY.ID = DIRECTORY_PARENT_ID
START WITH DIRECTORY.PARENT_ID IS NULL
ORDER BY 1]]></sql>
<java><![CDATA[create.select(sysConnectByPath(DIRECTORY.NAME, "/").substring(2))
      .from(DIRECTORY)
      .connectBy(prior(DIRECTORY.ID).equal(DIRECTORY.PARENT_ID))
      .startWith(DIRECTORY.PARENT_ID.isNull())
      .orderBy(one());]]></java>
</code-pair>

    										<p>
    											The output might then look like this
   											</p>

<text>+------------------------------------------------+
|substring                                       |
+------------------------------------------------+
|C:                                              |
|C:/eclipse                                      |
|C:/eclipse/configuration                        |
|C:/eclipse/dropins                              |
|C:/eclipse/eclipse.exe                          |
+------------------------------------------------+
|...21 record(s) truncated...
</text>

											<p>
												Some of the supported functions and pseudo-columns are these (available from the <reference id="factory" title="Factory"/>):
											</p>

											<ul>
												<li>LEVEL</li>
												<li>CONNECT_BY_IS_CYCLE</li>
												<li>CONNECT_BY_IS_LEAF</li>
												<li>CONNECT_BY_ROOT</li>
												<li>SYS_CONNECT_BY_PATH</li>
												<li>PRIOR</li>
											</ul>

											<p>
												Note that this syntax is also supported in the CUBRID database.
											</p>
										</content>
									</section>

									<section id="group-by-clause">
										<title>The GROUP BY clause</title>
										<content>
											<h3>The GROUP BY clause used for grouping and aggregations</h3>
											<p>
												GROUP BY can be used to create unique groups of data, to form aggregations, to remove duplicates and for other reasons. It will transform your previously defined <reference id="table-expressions" title="set of table expressions"/>, and return only one record per unique group as specified in this clause. For instance, you can group books by BOOK.AUTHOR_ID:
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, COUNT(*)
FROM BOOK
GROUP BY AUTHOR_ID]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, count())
      .from(BOOK)
      .groupBy(AUTHOR_ID);]]></java></code-pair>

											<p>
												As defined in the SQL standard, when grouping, you may no longer project any columns that are not a formal part of the GROUP BY clause, or <reference id="aggregate-functions" title="aggregate functions"/>. The above example counts all books per author
											</p>

											<h3>MySQL's deviation from the SQL standard</h3>
											<p>
												MySQL has a peculiar way of not adhering to this standard behaviour. This is documented in the <a href="http://dev.mysql.com/doc/refman/5.6/en/group-by-hidden-columns.html">MySQL manual</a>. In short, with MySQL, you can also project any other field that are not part of the GROUP BY clause. The projected values will just be arbitrary values from within the group. You cannot rely on any ordering. For example:
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, TITLE
FROM BOOK
GROUP BY AUTHOR_ID]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .groupBy(AUTHOR_ID);]]></java></code-pair>

											<p>
												This will return an arbitrary title per author. jOOQ supports this syntax, as jOOQ is not doing any checks internally, about the consistence of tables/fields/functions that you provide it.
											</p>

											<h3>ROLLUP(), CUBE() and GROUPING SETS()</h3>
											<p>
												Some databases support the SQL standard grouping functions and some extensions thereof. See the manual's section about <reference id="grouping-functions" title="grouping functions"/> for more details.
											</p>
										</content>
									</section>

									<section id="having-clause">
										<title>The HAVING clause</title>
										<content>
											<h3>Restrict results from the GROUP BY clause using HAVING</h3>
											<p>
												The HAVING clause is commonly used to further restrict data resulting from a previously issued <reference id="group-by-clause" title="GROUP BY clause"/>. An example, selecting only those authors that have written at least two books:
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, COUNT(*)
FROM BOOK
GROUP BY AUTHOR_ID
HAVING COUNT(*) >= 2]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, count(*))
      .from(BOOK)
      .groupBy(AUTHOR_ID)
      .having(count().greaterOrEqual(2));]]></java></code-pair>

											<p>
												According to the SQL standard, you may omit the GROUP BY clause and still issue a HAVING clause. This will implicitly GROUP BY (). jOOQ also supports this syntax. The following example selects one record, only if there are at least 4 books in the books table:
											</p>

<code-pair>
<sql><![CDATA[SELECT COUNT(*)
FROM BOOK
HAVING COUNT(*) >= 4]]></sql>
<java><![CDATA[create.select(count(*))
      .from(BOOK)
      .having(count().greaterOrEqual(4));]]></java></code-pair>

										</content>
									</section>

									<section id="order-by-clause">
										<title>The ORDER BY clause</title>
										<content>
											<h3>The ORDER BY clause</h3>
											<p>
												Databases are allowed to return data in any arbitrary order, unless you explicitly declare that order in the ORDER BY clause. In jOOQ, this is straight-forward:
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, TITLE
FROM BOOK
ORDER BY AUTHOR_ID ASC, TITLE DESC]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .orderBy(BOOK.AUTHOR_ID.asc(), BOOK.TITLE.desc());]]></java></code-pair>

											<p>
												Any jOOQ <reference id="column-expressions" title="column expression (or field)"/> can be transformed into an <reference class="org.jooq.SortField"/> by calling the asc() and desc() methods.
											</p>

											<h3>Ordering by field index</h3>
											<p>
												The SQL standard allows for specifying integer literals (<reference id="inlined-parameters" title="literals"/>, not <reference id="bind-values" title="bind values"/>!) to reference column indexes from the projection (<reference id="select-clause" title="SELECT clause"/>). This may be useful if you do not want to repeat a lengthy expression, by which you want to order - although most databases also allow for referencing <reference id="aliasing" title="aliased column references"/> in the ORDER BY clause. An example of this is given here:
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, TITLE
FROM BOOK
ORDER BY 1 ASC, 2 DESC]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .orderBy(one().asc(), inline(2).desc());]]></java></code-pair>

											<p>
												Note, how one() is used as a convenience short-cut for inline(1)
											</p>

											<h3>Ordering and NULLS</h3>
											<p>
												A few databases support the SQL standard "null ordering" clause in sort specification lists, to define whether NULL values should come first or last in an ordered result.
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, CO_AUTHOR_ID, TITLE
FROM BOOK
ORDER BY AUTHOR_ID ASC,
         CO_AUTHOR_ID ASC NULLS LAST]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, BOOK.CO_AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .orderBy(BOOK.AUTHOR_ID.asc(),
               BOOK.CO_AUTHOR_ID.asc().nullsLast());]]></java></code-pair>

											<p>
												If your database doesn't support this syntax, jOOQ simulates it using a <reference id="case-expressions" title="CASE expression"/> as follows
											</p>
<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, CO_AUTHOR_ID, TITLE
FROM BOOK
ORDER BY AUTHOR_ID ASC,
    CASE WHEN CO_AUTHOR_ID IS NULL THEN 1 ELSE 0 END ASC,
         CO_AUTHOR_ID ASC]]></sql>
<java><![CDATA[

create.select(BOOK.AUTHOR_ID, BOOK.CO_AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .orderBy(BOOK.AUTHOR_ID.asc(),
               BOOK.CO_AUTHOR_ID.asc().nullsLast());]]></java></code-pair>

											<h3>Ordering using CASE expressions</h3>
											<p>
												Using <reference id="case-expressions" title="CASE expressions"/> in SQL ORDER BY clauses is a common pattern, if you want to introduce some sort indirection / sort mapping into your queries. As with SQL, you can add any type of <reference id="column-expressions" title="column expression"/> into your ORDER BY clause. For instance, if you have two favourite books that you always want to appear on top, you could write:
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
ORDER BY CASE TITLE
         WHEN '1984' THEN 0
         WHEN 'Animal Farm' THEN 1
         ELSE 2 END ASC]]></sql>
<java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(decode().value(BOOK.TITLE)
                       .when("1984", 0)
                       .when("Animal Farm", 1)
                       .otherwise(2).asc());]]></java></code-pair>

											<p>
												But writing these things can become quite verbose. jOOQ supports a convenient syntax for specifying sort mappings. The same query can be written in jOOQ as such:
											</p>

<java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(BOOK.TITLE.sortAsc("1984", "Animal Farm"));]]></java>

											<p>
												More complex sort indirections can be provided using a Map:
											</p>

<java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(BOOK.TITLE.sort(new HashMap<String, Integer>() {{
          put("1984", 1);
          put("Animal Farm", 13);
          put("The jOOQ book", 10);
      }}));]]></java>

      										<p>
      											Of course, you can combine this feature with the previously discussed NULLS FIRST / NULLS LAST feature. So, if in fact these two books are the ones you like least, you can put all NULLS FIRST (all the other books):
      										</p>

<java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(BOOK.TITLE.sortAsc("1984", "Animal Farm").nullsFirst());]]></java>

											<h3>jOOQ's understanding of SELECT .. ORDER BY</h3>
											<p>
												The SQL standard defines that a "query expression" can be ordered, and that query expressions can contain <reference id="union-clause" title="UNION, INTERSECT and EXCEPT clauses"/>, whose subqueries cannot be ordered. While this is defined as such in the SQL standard, many databases allowing for the non-standard <reference id="limit-clause" title="LIMIT clause"/> in one way or another, do not adhere to this part of the SQL standard. Hence, jOOQ allows for ordering all SELECT statements, regardless whether they are constructed as a part of a UNION or not. Corner-cases are handled internally by jOOQ, by introducing synthetic subselects to adhere to the correct syntax, where this is needed.
											</p>
										</content>
									</section>

									<section id="limit-clause">
										<title>The LIMIT .. OFFSET clause</title>
										<content>
											<h3>The non-standard LIMIT .. OFFSET clause</h3>
											<p>
												While being extremely useful for every application that does paging, or just to limit result sets to reasonable sizes, this clause is not yet part of any SQL standard (up until SQL:2008). Hence, there exist a variety of possible implementations in various SQL dialects, concerning this limit clause. jOOQ chose to implement the LIMIT .. OFFSET clause as understood and supported by MySQL, H2, HSQLDB, Postgres, and SQLite. Here is an example of how to apply limits with jOOQ:
											</p>

<java><![CDATA[create.select().from(BOOK).limit(1).offset(2);]]></java>

											<p>
												This will limit the result to 1 books starting with the 2nd book (starting at offset 0!). limit() is supported in all dialects, offset() in all but Sybase ASE, which has no reasonable means to simulate it. This is how jOOQ simulates the above query in various SQL dialects:
											</p>

<sql><![CDATA[-- MySQL, H2, HSQLDB, Postgres, and SQLite
SELECT * FROM BOOK LIMIT 1 OFFSET 2

-- CUBRID supports a MySQL variant of the LIMIT .. OFFSET clause
SELECT * FROM BOOK LIMIT 2, 1

-- Derby
SELECT * FROM BOOK OFFSET 2 ROWS FETCH NEXT 1 ROWS ONLY

-- Ingres
SELECT * FROM BOOK OFFSET 2 FETCH FIRST 1 ROWS ONLY

-- Sybase SQL Anywhere
SELECT TOP 1 ROWS START AT 3 * FROM BOOK

-- DB2 (without OFFSET)
SELECT * FROM BOOK FETCH FIRST 1 ROWS ONLY

-- Sybase ASE, SQL Server (without OFFSET)
SELECT TOP 1 * FROM BOOK

-- DB2 (with OFFSET), SQL Server (with OFFSET), Oracle (actual query may vary)
SELECT * FROM (
  SELECT LIMIT_98843777.*, ROW_NUMBER() OVER (ORDER BY ID ASC) AS ROWNUM_98843777
  FROM (
    SELECT TOP 100 PERCENT *
    FROM BOOK
    ORDER BY ID ASC
  ) AS LIMIT_98843777
) AS OUTER_LIMIT_98843777
WHERE ROWNUM_98843777 > 1
AND ROWNUM_98843777 <= 3
]]></sql>

											<p>
												As you can see, jOOQ will take care of the incredibly painful ROW_NUMBER() OVER() (or ROWNUM for Oracle) filtering in subselects for you, you'll just have to write limit(1).offset(2) in any dialect.
											</p>

											<h3>SQL Server's ORDER BY, TOP and subqueries</h3>
											<p>
												As can be seen in the above example, writing correct SQL can be quite tricky, depending on the SQL dialect. For instance, with SQL Server, you cannot have an ORDER BY clause in a subquery, unless you also have a TOP clause. This is illustrated by the fact that jOOQ renders a TOP 100 PERCENT clause for you. The same applies to the fact that ROW_NUMBER() OVER() needs an ORDER BY windowing clause, even if you don't provide one to the jOOQ query. By default, jOOQ adds ordering by the first column of your projection.
											</p>
										</content>
									</section>

									<section id="for-update-clause">
										<title>The FOR UPDATE clause</title>
										<content>
											<h3>Pessimistic (exclusive) locking with the FOR UPDATE clause</h3>
											<p>
												For inter-process synchronisation and other reasons, you may choose to use the SELECT .. FOR UPDATE clause to indicate to the database, that a set of cells or records should be locked by a given transaction for subsequent updates. With jOOQ, this can be achieved as such:
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE ID = 3
FOR UPDATE]]></sql>
<java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.ID.equal(3))
      .forUpdate();]]></java></code-pair>

											<p>
												The above example will produce a record-lock, locking the whole record for updates. Some databases also support cell-locks using FOR UPDATE OF ..
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE ID = 3
FOR UPDATE OF TITLE]]></sql>
<java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.ID.equal(3))
      .forUpdate().of(BOOK.TITLE);]]></java></code-pair>

											<p>
												Oracle goes a bit further and also allows to specify the actual locking behaviour. It features these additional clauses, which are all supported by jOOQ:
											</p>
											<ul>
												<li>FOR UPDATE NOWAIT: This is the default behaviour. If the lock cannot be acquired, the query fails immediately</li>
												<li>FOR UPDATE WAIT n: Try to wait for [n] seconds for the lock acquisition. The query will fail only afterwards</li>
												<li>FOR UPDATE SKIP LOCKED: This peculiar syntax will skip all locked records. This is particularly useful when implementing queue tables with multiple consumers</li>
											</ul>
											<p>
												With jOOQ, you can use those Oracle extensions as such:
											</p>

<java><![CDATA[create.select().from(BOOK).where(BOOK.ID.equal(3)).forUpdate().nowait();
create.select().from(BOOK).where(BOOK.ID.equal(3)).forUpdate().wait(5);
create.select().from(BOOK).where(BOOK.ID.equal(3)).forUpdate().skipLocked();]]></java>

											<h3>FOR UPDATE in CUBRID and SQL Server</h3>
											<p>
												The SQL standard specifies a FOR UPDATE clause to be applicable for cursors. Most databases interpret this as being applicable for all SELECT statements. An exception to this rule are the CUBRID and SQL Server databases, that do not allow for any FOR UPDATE clause in a regular SQL SELECT statement. jOOQ simulates the FOR UPDATE behaviour, by locking record by record with JDBC. JDBC allows for specifying the flags TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE for any statement, and then using ResultSet.updateXXX() methods to produce a cell-lock / row-lock. Here’s a simplified example in JDBC:
											</p>
<java><![CDATA[PreparedStatement stmt = connection.prepareStatement(
  "SELECT * FROM author WHERE id IN (3, 4, 5)",
  ResultSet.TYPE_SCROLL_SENSITIVE,
  ResultSet.CONCUR_UPDATABLE);
ResultSet rs = stmt.executeQuery();

while (rs.next()) {
  // UPDATE the primary key for row-locks, or any other columns for cell-locks
  rs.updateObject(1, rs.getObject(1));
  rs.updateRow();

  // Do more stuff with this record
}]]></java>

											<p>
												The main drawback of this approach is the fact that the database has to maintain a scrollable cursor, whose records are locked one by one. This can cause a major risk of deadlocks or race conditions if the JDBC driver can recover from the unsuccessful locking, if two Java threads execute the following statements:
											</p>

<sql><![CDATA[-- thread 1
SELECT * FROM author ORDER BY id ASC;

-- thread 2
SELECT * FROM author ORDER BY id DESC;]]></sql>

											<p>
												So use this technique with care, possibly only ever locking single rows!
											</p>

											<h3>Pessimistic (shared) locking with the FOR SHARE clause</h3>
											<p>
												Some databases (MySQL, Postgres) also allow to issue a non-exclusive lock explicitly using a FOR SHARE clause. This is also supported by jOOQ
											</p>

											<h3>Optimistic locking in jOOQ</h3>
											<p>
												Note, that jOOQ also supports optimistic locking, if you're doing simple CRUD. This is documented in the section's manual about <reference id="optimistic-locking" title="optimistic locking"/>.
											</p>
										</content>
									</section>

									<section id="union-clause">
										<title>UNION, INTERSECTION and EXCEPT</title>
										<content></content>
									</section>

									<section id="oracle-hints">
										<title>Oracle-style hints</title>
										<content>
											<h3>How to embed Oracle hints in SELECT</h3>
											<p>
												If you are closely coupling your application to an Oracle (or CUBRID) database,	you might need to be able to pass hints of the form /*+HINT*/ with your SQL statements to the Oracle database. For example:
											</p>

<sql>SELECT /*+ALL_ROWS*/ FIRST_NAME, LAST_NAME
  FROM AUTHOR</sql>

				  							<p>
				  								This can be done in jOOQ using the .hint() clause in your SELECT statement:
			  								</p>

<java>create.select(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .hint("/*+ALL_ROWS*/")
      .from(AUTHOR);</java>

											<p>
												Note that you can pass any string in the .hint() clause. If you use that clause, the passed string will always be put in between the SELECT [DISTINCT] keywords and the actual projection list
											</p>
										</content>
									</section>
								</sections>
							</section>

							<section id="insert-statement">
								<title>The INSERT statement</title>
								<content></content>
							</section>

							<section id="update-statement">
								<title>The UPDATE statement</title>
								<content></content>
							</section>

							<section id="delete-statement">
								<title>The DELETE statement</title>
								<content></content>
							</section>

							<section id="merge-statement">
								<title>The MERGE statement</title>
								<content></content>
							</section>

							<section id="truncate-statement">
								<title>The TRUNCATE statement</title>
								<content></content>
							</section>
						</sections>
					</section>

					<section id="table-expressions">
						<title>Table expressions</title>
						<content></content>

						<sections>
							<section id="generated-tables">
								<title>Generated Tables</title>
								<content></content>
							</section>

							<section id="joined-tables">
								<title>Joined tables</title>
								<content></content>
							</section>

							<section id="nested-selects">
								<title>Nested SELECTs</title>
								<content></content>
							</section>

							<section id="pivot-tables">
								<title>PIVOT tables</title>
								<content></content>
							</section>

							<section id="relational-division">
								<title>jOOQ's relational division syntax</title>
								<content>
									<h3>Relational division</h3>
									<p>
									    There is one operation in relational algebra that is not given a lot of attention, because it is rarely used in real-world applications. It is the relational division, the opposite operation of the cross product (or, relational multiplication). The following is an approximate definition of a relational division:
									</p>

<config>Assume the following cross join / cartesian product
C = A × B

Then it can be said that
A = C ÷ B
B = C ÷ A</config>

									<p>
									   With jOOQ, you can simplify using relational divisions by using the following syntax:
									</p>

<java>C.divideBy(B).on(C.ID.equal(B.C_ID)).returning(C.TEXT)</java>

									<p>
										The above roughly translates to
									</p>

<sql>SELECT DISTINCT C.TEXT FROM C "c1"
WHERE NOT EXISTS (
  SELECT 1 FROM B
  WHERE NOT EXISTS (
    SELECT 1 FROM C "c2"
    WHERE "c2".TEXT = "c1".TEXT
    AND "c2".ID = B.C_ID
  )
)</sql>

									<p>
										Or in plain text: Find those TEXT values in C whose ID's correspond to all ID's in B. Note that from the above SQL statement, it is immediately clear that proper indexing is of the essence. Be sure to have indexes on all columns referenced from the on(...) and returning(...) clauses.
									</p>

									<p>
										For more information about relational division and some nice, real-life examples, see
									</p>

									<ul>
										<li><a href="http://en.wikipedia.org/wiki/Relational_algebra#Division" title="Wikipedia article on relational division">http://en.wikipedia.org/wiki/Relational_algebra#Division</a></li>
										<li><a href="http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/" title="A nice summary of what relational division is and how it is best implemented in SQL">http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/</a></li>
									</ul>
								</content>

							</section>

							<section id="array-and-cursor-unnesting">
								<title>Array and cursor unnesting</title>
								<content></content>
							</section>

							<section id="dual">
								<title>The DUAL table</title>
								<content>
									<h3>Selecting from DUAL</h3>
									<p>
										The SQL standard specifies that the <reference id="from-clause" title="FROM clause"/> is optional in a <reference id="select-statement" title="SELECT statement"/>. However, according to the standard, you may then no longer use some other clauses, such as the <reference id="where-clause" title="WHERE clause"/>. In the real world, there exist three types of databases:
									</p>
									<ul>
										<li>The ones that always require a FROM clause</li>
										<li>The ones that never require a FROM clause (and still allow a WHERE clause)</li>
										<li>The ones that correctly implement the SQL standard</li>
									</ul>
									<p>
										With jOOQ, you don't have to worry about the above distinction of SQL dialects. jOOQ never requires a FROM clause, but renders the necessary "DUAL" table, if needed. The following program shows how jOOQ renders "DUAL" tables
									</p>

<code-pair>
	<sql><![CDATA[SELECT 1
SELECT 1 FROM "db_root"
SELECT 1 FROM "SYSIBM"."DUAL"
SELECT 1 FROM "SYSIBM"."SYSDUMMY1"
SELECT 1 FROM dual
SELECT 1 FROM "INFORMATION_SCHEMA"."SYSTEM_USERS"
SELECT 1 FROM (select 1 as dual) as dual
SELECT 1 FROM dual
SELECT 1 FROM dual
SELECT 1
SELECT 1
SELECT 1
SELECT 1 FROM [SYS].[DUMMY]
]]></sql>
	<java><![CDATA[new Factory(SQLDialect.ASE      ).selectOne().getSQL();
new Factory(SQLDialect.CUBRID   ).selectOne().getSQL();
new Factory(SQLDialect.DB2      ).selectOne().getSQL();
new Factory(SQLDialect.DERBY    ).selectOne().getSQL();
new Factory(SQLDialect.H2       ).selectOne().getSQL();
new Factory(SQLDialect.HSQLDB   ).selectOne().getSQL();
new Factory(SQLDialect.INGRES   ).selectOne().getSQL();
new Factory(SQLDialect.MYSQL    ).selectOne().getSQL();
new Factory(SQLDialect.ORACLE   ).selectOne().getSQL();
new Factory(SQLDialect.POSTGRES ).selectOne().getSQL();
new Factory(SQLDialect.SQLITE   ).selectOne().getSQL();
new Factory(SQLDialect.SQLSERVER).selectOne().getSQL();
new Factory(SQLDialect.SYBASE   ).selectOne().getSQL();]]></java>
</code-pair>

									<p>
										Note, that some databases (H2, MySQL) can normally do without "dual". However, there exist some corner-cases with complex nested SELECT statements, where this will cause syntax errors (or parser bugs). To stay on the safe side, jOOQ will always render "dual" in those dialects.
									</p>
								</content>
							</section>
						</sections>
					</section>

					<section id="column-expressions">
						<title>Column expressions</title>
						<content>
							<h3>Column expressions in general</h3>
							<p>
								jOOQ allows you to freely create arbitrary column expressions using a fluent expression construction API. Many expressions can be formed as functions from <reference id="factory" title="Factory methods"/>, other expressions can be formed based on a pre-existing column expression. For example:
							</p>
							
<java><![CDATA[// A regular table column expression
Field<String> field1 = BOOK.TITLE;

// A function created from the Factory using "prefix" notation
Field<String> field2 = trim(BOOK.TITLE);

// The same function created from a pre-existing Field using "postfix" notation
Field<String> field3 = BOOK.TITLE.trim();

// More complex function with advanced DSL syntax
Field<String> field4 = listAgg(BOOK.TITLE)
                          .withinGroupOrderBy(BOOK.ID.asc())
                          .over().partitionBy(AUTHOR.ID);]]></java>

							<p>
								In general, it is up to you whether you want to use the "prefix" notation or the "postfix" notation to create new column expressions based on existing ones. The "SQL way" would be to use the "prefix notation", with functions created from the <reference id="factory" title="Factory"/>. The "Java way" or "object-oriented way" would be to use the "postfix" notation with functions created from <reference class="org.jooq.Field"/> objects. Both ways ultimately create the same query part, though.
							</p>
						</content>

						<sections>
							<section id="table-columns">
								<title>Table columns</title>
								<content></content>
							</section>

							<section id="aliasing">
								<title>Aliasing</title>
								<content></content>
							</section>

							<section id="cast-expressions">
								<title>Cast expressions</title>
								<content>
									<h3>Enforcing a specific type when you need it</h3>
									<p>
										jOOQ's source code generator tries to find the most accurate type mapping between your vendor-specific data types and a matching Java type. For instance, most VARCHAR, CHAR, CLOB types will map to String. Most BINARY, BYTEA, BLOB types will map to byte[]. NUMERIC types will default to java.math.BigDecimal, but can also be any of java.math.BigInteger, Long, Integer, Short, Byte, Double, Float.
									</p>
									<p>
										Sometimes, this automatic mapping might not be what you needed, or jOOQ cannot know the type of a field. In those cases you would write SQL type CASTs like this:
									</p>
									
<sql>-- Let's say, your Postgres column LAST_NAME was VARCHAR(30)
-- Then you could do this:
SELECT CAST(T_AUTHOR.LAST_NAME AS TEXT) FROM DUAL</sql>

									<p>
										in jOOQ, you can write something like that:
									</p>
									
<java>create.select(TAuthor.LAST_NAME.cast(PostgresDataType.TEXT));</java>

									<p>
										The same thing can be achieved by casting a Field directly to String.class, as TEXT is the default data type in Postgres to map to Java's String
									</p>
									
<java>create.select(TAuthor.LAST_NAME.cast(String.class));</java>
		
									<p>
										The complete CAST API in Field consists of these three methods:
									</p>
									
<java><![CDATA[public interface Field<T> {

    // Cast this field to the type of another field
    <Z> Field<Z> cast(Field<Z> field);
    
    // Cast this field to a given DataType
    <Z> Field<Z> cast(DataType<Z> type);
    
    // Cast this field to the default DataType for a given Class
    <Z> Field<Z> cast(Class<? extends Z> type);
}

// And additional convenience methods in the Factory:
public class Factory {
    <T> Field<T> cast(Object object, Field<T> field);
    <T> Field<T> cast(Object object, DataType<T> type);
    <T> Field<T> cast(Object object, Class<? extends T> type);
    <T> Field<T> castNull(Field<T> field);
    <T> Field<T> castNull(DataType<T> type);
    <T> Field<T> castNull(Class<? extends T> type);
}]]></java>
								</content>
							</section>

							<section id="arithmetic-expressions">
								<title>Arithmetic expressions</title>
								<content>
									<h3>Numeric arithmetic expressions</h3>
									<p>
										Your database can do the math for you. Arithmetic operations are implemented just like <reference id="numeric-functions" title="numeric functions"/>, with similar limitations as far as type restrictions are concerned. You can use any of these operators:
									</p>

<config>  +  -  *  /  %</config>

									<p>
										In order to express a SQL query like this one:
									</p>
									
<sql>SELECT ((1 + 2) * (5 - 3) / 2) % 10 FROM DUAL</sql>
							
									<p>
										You can write something like this in jOOQ:
									</p>
									
<java>create.select(val(1).add(2).mul(val(5).sub(3)).div(2).mod(10);</java>

									<h3>Datetime arithmetic expressions</h3>
									<p>
										jOOQ also supports the Oracle-style syntax for adding days to a Field&lt;? extends java.util.Date&gt; 
									</p>

<code-pair>
	<sql>SELECT SYSDATE + 3 FROM DUAL;</sql>
	<java>create.select(currentTimestamp().add(3));</java>
</code-pair>

									<p>
										For more advanced datetime arithmetic, use the Factory's timestampDiff() and dateDiff() functions, as well as jOOQ's built-in SQL standard INTERVAL data type support:
									</p>
									<ul>
										<li>INTERVAL YEAR TO MONTH: <reference class="org.jooq.types.YearToMonth"/></li>
										<li>INTERVAL DAY TO SECOND: <reference class="org.jooq.types.DayToSecond"/></li>
									</ul>
								</content>
							</section>
							
							<section id="string-concatenation">
								<title>String concatenation</title>
								<content>
									<h3>String concatenation</h3>
									<p>
										The SQL standard defines the concatenation operator to be an infix operator, similar to the ones we've seen in the chapter about <reference id="arithmetic-expressions" title="arithmetic expressions"/>. This operator looks like this: <code>||</code>. Some other dialects do not support this operator, but expect a <code>concat()</code> function, instead. jOOQ renders the right operator / function, depending on your <reference id="sql-dialects" title="SQL dialect"/>:
									</p>
									
<code-pair>
<sql>SELECT 'A' || 'B' || 'C' FROM DUAL
-- Or in MySQL:
SELECT concat('A', 'B', 'C') FROM DUAL</sql>
<java>&#160;
// For all RDBMS, including MySQL:
create.select(concat("A", "B", "C"));
</java>
</code-pair>								
								</content>
							</section>

							<section id="numeric-functions">
								<title>Numeric functions</title>
								<content></content>
							</section>

							<section id="bitwise-functions">
								<title>Bitwise functions</title>
								<content></content>
							</section>

							<section id="string-functions">
								<title>String functions</title>
								<content></content>
							</section>

							<section id="date-and-time-functions">
								<title>Date and time functions</title>
								<content></content>
							</section>

							<section id="system-functions">
								<title>System functions</title>
								<content></content>
							</section>

							<section id="aggregate-functions">
								<title>Aggregate functions</title>
								<content>
									<h3>Aggregate functions</h3>
									<p>
										Aggregate functions work just like functions, even if they have a slightly different semantics. Here are some example aggregate functions from the <reference id="factory" title="Factory"/>:
									</p>

<java><![CDATA[// Every-day, SQL standard aggregate functions
AggregateFunction<Integer> count();
AggregateFunction<Integer> count(Field<?> field);
AggregateFunction<T> max(Field<T> field);
AggregateFunction<T> min(Field<T> field);
AggregateFunction<BigDecimal> sum(Field<? extends Number> field);
AggregateFunction<BigDecimal> avg(Field<? extends Number> field);

// DISTINCT keyword in aggregate functions
AggregateFunction<Integer> countDistinct(Field<?> field);
AggregateFunction<T> maxDistinct(Field<T> field);
AggregateFunction<T> minDistinct(Field<T> field);
AggregateFunction<BigDecimal> sumDistinct(Field<? extends Number> field);
AggregateFunction<BigDecimal> avgDistinct(Field<? extends Number> field);

// String aggregate functions
AggregateFunction<String> groupConcat(Field<?> field);
AggregateFunction<String> groupConcatDistinct(Field<?> field);
OrderedAggregateFunction<String> listAgg(Field<?> field);
OrderedAggregateFunction<String> listAgg(Field<?> field, String separator);

// Statistical functions
AggregateFunction<BigDecimal> median(Field<? extends Number> field);
AggregateFunction<BigDecimal> stddevPop(Field<? extends Number> field);
AggregateFunction<BigDecimal> stddevSamp(Field<? extends Number> field);
AggregateFunction<BigDecimal> varPop(Field<? extends Number> field);
AggregateFunction<BigDecimal> varSamp(Field<? extends Number> field);]]></java>

									<p>
										Here's an example, counting the number of books any author has written:
									</p>

<code-pair>
<sql>SELECT AUTHOR_ID, COUNT(*)
FROM BOOK
GROUP BY AUTHOR_ID</sql>
<java>create.select(BOOK.AUTHOR_ID, count())
      .from(BOOK)
      .groupBy(BOOK.AUTHOR_ID);</java>
</code-pair>

									<p>
										Aggregate functions have strong limitations about when they may be used and when not. For instance, you can use aggregate functions in scalar queries. Typically, this means you only select aggregate functions, no <reference id="table-columns" title="regular columns"/> or other <reference id="column-expressions" title="column expressions"/>. Another use case is to use them along with a <reference id="group-by-clause" title="GROUP BY clause"/> as seen in the previous example. Note, that jOOQ does not check whether your using of aggregate functions is correct according to the SQL standards, or according to your database's behaviour.
									</p>

		                            <h3>Ordered aggregate functions</h3>
		                            <p>
		                            	Oracle and some other databases support "ordered aggregate functions". This means you can provide an ORDER BY clause to an aggregate function, which will be taken into consideration when aggregating. The best example for this is Oracle's <code>LISTAGG()</code> (also known as <code>GROUP_CONCAT</code> in other <reference id="sql-dialects" title="SQL dialects"/>). The following query groups by authors and concatenates their books' titles
		                           	</p>
<code-pair>
<sql>SELECT   LISTAGG(TITLE, ', ')
         WITHIN GROUP (ORDER BY TITLE)
FROM     BOOK
GROUP BY AUTHOR_ID</sql>
<java>create.select(listAgg(BOOK.TITLE, ", ")
      .withinGroupOrderBy(BOOK.TITLE))
      .from(BOOK)
      .groupBy(BOOK.AUTHOR_ID)</java>
</code-pair>

									<p>
										The above query might yield:
									</p>

<text>+---------------------+
| LISTAGG             |
+---------------------+
| 1984, Animal Farm   |
| O Alquimista, Brida |
+---------------------+</text>

									<h3>FIRST and LAST: Oracle's "ranked" aggregate functions</h3>
									<p>
										Oracle allows for restricting aggregate functions using the <code>KEEP()</code> clause, which is supported by jOOQ. In Oracle, some aggregate functions (MIN, MAX, SUM, AVG, COUNT, VARIANCE, or STDDEV) can be restricted by this clause, hence <reference class="org.jooq.AggregateFunction"/> also allows for specifying it. Here are a couple of examples using this clause:
									</p>

<code-pair>
<sql>SUM(BOOK.AMOUNT_SOLD)
  KEEP(DENSE_RANK FIRST ORDER BY BOOK.AUTHOR_ID)</sql>
<java>sum(BOOK.AMOUNT_SOLD)
  .keepDenseRankFirstOrderBy(BOOK.AUTHOR_ID)</java>
</code-pair>

									<h3>User-defined aggregate functions</h3>
									<p>
										jOOQ also supports using your own user-defined aggregate functions. See the manual's section about <reference id="user-defined-aggregate-functions" title="user-defined aggregate functions"/> for more details.
									</p>

									<h3>Window functions / analytical functions</h3>
									<p>
										In those databases that support <reference id="window-functions" title="window functions"/>, jOOQ's <reference class="org.jooq.AggregateFunction"/> can be transformed into a window function / analytical function by calling <code>over()</code> on it. See the manual's section about <reference id="window-functions" title="window functions"/> for more details.
									</p>
								</content>
							</section>

							<section id="window-functions">
								<title>Window functions</title>
								<content>
									<h3>Window functions</h3>
									<p>
										Most major RDBMS support the concept of window functions. jOOQ knows of implementations in DB2, Oracle, Postgres, SQL Server, and Sybase SQL Anywhere, and supports most of their specific syntaxes. Note, that H2 and HSQLDB have implemented <code>ROW_NUMBER()</code> functions, without true windowing support.
									</p>
									<p>
										As previously discussed, any <reference class="org.jooq.AggregateFunction"/> can be transformed into a window function using the <code>over()</code> method. See the chapter about <reference id="aggregate-functions" title="aggregate functions"/> for details. In addition to those, there are also some more window functions supported by jOOQ, as declared in the <reference id="factory" title="Factory"/>:
									</p>

<java><![CDATA[// Ranking functions
    WindowOverStep<Integer>    rowNumber();
    WindowOverStep<Integer>    rank();
    WindowOverStep<Integer>    denseRank();
    WindowOverStep<BigDecimal> percentRank();
    
// Windowing functions
<T> WindowIgnoreNullsStep<T>   firstValue(Field<T> field);
<T> WindowIgnoreNullsStep<T>   lastValue(Field<T> field)
<T> WindowIgnoreNullsStep<T>   lead(Field<T> field);
<T> WindowIgnoreNullsStep<T>   lead(Field<T> field, int offset);
<T> WindowIgnoreNullsStep<T>   lead(Field<T> field, int offset, T defaultValue);
<T> WindowIgnoreNullsStep<T>   lead(Field<T> field, int offset, Field<T> defaultValue);
<T> WindowIgnoreNullsStep<T>   lag(Field<T> field);
<T> WindowIgnoreNullsStep<T>   lag(Field<T> field, int offset);
<T> WindowIgnoreNullsStep<T>   lag(Field<T> field, int offset, T defaultValue);
<T> WindowIgnoreNullsStep<T>   lag(Field<T> field, int offset, Field<T> defaultValue);

// Statistical functions
    WindowOverStep<BigDecimal> cumeDist();
    WindowOverStep<Integer>    ntile(int number);]]></java>	
    								
    								<p>
    									SQL distinguishes between various window function types (e.g. "ranking functions"). Depending on the function, SQL expects mandatory <code>PARTITION BY</code> or <code>ORDER BY</code> clauses within the <code>OVER()</code> clause. jOOQ does not enforce those rules for two reasons:
    								</p>
    								<ul>
    									<li>Your JDBC driver or database already checks SQL syntax semantics</li>
    									<li>Not all databases behave correctly according to the SQL standard</li>
    								</ul>
    								<p>
    									If possible, however, jOOQ tries to render missing clauses for you, if a given <reference id="sql-dialects" title="SQL dialect"/> is more restrictive.
    								</p>
    								<h3>Some examples</h3>
									<p>
										 Here are some simple examples of window functions with jOOQ:
									</p>
									
<code-pair>
<sql>-- Sample uses of ROW_NUMBER()
ROW_NUMBER() OVER()
ROW_NUMBER() OVER(PARTITION BY 1)
ROW_NUMBER() OVER(ORDER BY BOOK.ID)
ROW_NUMBER() OVER(PARTITION BY BOOK.AUTHOR_ID ORDER BY BOOK.ID)
                  
-- Sample uses of FIRST_VALUE
FIRST_VALUE(BOOK.ID) OVER()
FIRST_VALUE(BOOK.ID IGNORE NULLS) OVER()
FIRST_VALUE(BOOK.ID RESPECT NULLS) OVER()
</sql>
<java>// Sample uses of rowNumber()
rowNumber().over()
rowNumber().over().partitionByOne()
rowNumber().over().partitionBy(BOOK.AUTHOR_ID)
rowNumber().over().partitionBy(BOOK.AUTHOR_ID).orderBy(BOOK.ID)
                  
// Sample uses of firstValue()
firstValue(BOOK.ID).over()
firstValue(BOOK.ID).ignoreNulls().over()
firstValue(BOOK.ID).respectNulls().over()
</java>
</code-pair>
    								
									<h3>An advanced window function example</h3>
									<p>
										Window functions can be used for things like calculating a "running total". The following example fetches transactions and the running total for every transaction going back to the beginning of the transaction table (ordered by booked_at). Window functions are accessible from the previously seen <reference class="org.jooq.AggregateFunction"/> type using the <code>over()</code> method:
									</p>

<code-pair>
<sql>SELECT booked_at, amount,
   SUM(amount) OVER (PARTITION BY 1
                     ORDER BY booked_at
                     ROWS BETWEEN UNBOUNDED PRECEDING
                     AND CURRENT ROW) AS total
  FROM transactions</sql>
<java>create.select(t.BOOKED_AT, t.AMOUNT,
         sum(t.AMOUNT).over().partitionByOne()
                      .orderBy(t.BOOKED_AT)
                      .rowsBetweenUnboundedPreceding()
                      .andCurrentRow().as("total")
      .from(TRANSACTIONS.as("t"));</java>
</code-pair>


									<h3>Window functions created from ordered aggregate functions</h3>
									<p>
										In the previous chapter about <reference id="aggregate-functions" title="aggregate functions"/>, we have seen the concept of "ordered aggregate functions", such as Oracle's <code>LISTAGG()</code>. These functions have a window function / analytical function variant, as well. For example:
									</p>
									
<code-pair>
<sql>SELECT   LISTAGG(TITLE, ', ')
         WITHIN GROUP (ORDER BY TITLE)
         OVER (PARTITION BY BOOK.AUTHOR_ID)
FROM     BOOK</sql>
<java>create.select(listAgg(BOOK.TITLE, ", ")
      .withinGroupOrderBy(BOOK.TITLE)
      .over().partitionBy(BOOK.AUTHOR_ID))
      .from(BOOK)</java>
</code-pair>

									<h3>Window functions created from Oracle's FIRST and LAST aggregate functions</h3>
									<p>
										In the previous chapter about <reference id="aggregate-functions" title="aggregate functions"/>, we have seen the concept of "FIRST and LAST aggregate functions". These functions have a window function / analytical function variant, as well. For example:
									</p>

<code-pair>
<sql>SUM(BOOK.AMOUNT_SOLD)
  KEEP(DENSE_RANK FIRST ORDER BY BOOK.AUTHOR_ID)
  OVER(PARTITION BY 1)</sql>
<java>sum(BOOK.AMOUNT_SOLD)
  .keepDenseRankFirstOrderBy(BOOK.AUTHOR_ID)
  .over().partitionByOne()</java>
</code-pair>


									<h3>Window functions created from user-defined aggregate functions</h3>
									<p>
										User-defined aggregate functions also implement <reference class="org.jooq.AggregateFunction"/>, hence they can also be transformed into window functions using <code>over()</code>. This is supported by Oracle in particular. See the manual's section about <reference id="user-defined-aggregate-functions" title="user-defined aggregate functions"/> for more details.
									</p>
								</content>
							</section>

							<section id="grouping-functions">
								<title>Grouping functions</title>
								<content>
									<h3>ROLLUP() explained in SQL</h3>
									<p>
										The SQL standard defines special functions that can be used in the <reference id="group-by-clause" title="GROUP BY clause"/>: the grouping functions. These functions can be used to generate several groupings in a single clause. This can best be explained in SQL. Let's take ROLLUP() for instance:
									</p>

<code-pair>
<sql><![CDATA[-- ROLLUP() with one argument 
SELECT AUTHOR_ID, COUNT(*)
FROM BOOK
GROUP BY ROLLUP(AUTHOR_ID)


-- ROLLUP() with two arguments
SELECT AUTHOR_ID, PUBLISHED_IN, COUNT(*)
FROM BOOK
GROUP BY ROLLUP(AUTHOR_ID, PUBLISHED_IN)







]]></sql>
<sql><![CDATA[-- The same query using UNION ALL:
  SELECT AUTHOR_ID, COUNT(*) FROM BOOK GROUP BY (AUTHOR_ID)
UNION ALL
  SELECT NULL, COUNT(*) FROM BOOK GROUP BY ()
ORDER BY 1 NULLS LAST

-- The same query using UNION ALL:
  SELECT AUTHOR_ID, PUBLISHED_IN, COUNT(*) 
  FROM BOOK GROUP BY (AUTHOR_ID, PUBLISHED_IN)
UNION ALL
  SELECT AUTHOR_ID, NULL, COUNT(*) 
  FROM BOOK GROUP BY (AUTHOR_ID)
UNION ALL
  SELECT NULL, NULL, COUNT(*) 
  FROM BOOK GROUP BY ()
ORDER BY 1 NULLS LAST, 2 NULLS LAST
]]></sql>
</code-pair>

									<p>
										In English, the <code>ROLLUP()</code> grouping function provides <code>N+1</code> groupings, when <code>N</code> is the number of arguments to the <code>ROLLUP()</code> function. Each grouping has an additional group field from the <code>ROLLUP()</code> argument field list. The results of the second query might look something like this:
									</p>
									
<text><![CDATA[+-----------+--------------+----------+
| AUTHOR_ID | PUBLISHED_IN | COUNT(*) |
+-----------+--------------+----------+
|         1 |         1945 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         1 |         1948 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         1 |         NULL |        2 | <- GROUP BY (AUTHOR_ID)
|         2 |         1988 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         2 |         1990 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         2 |         NULL |        2 | <- GROUP BY (AUTHOR_ID)
|      NULL |         NULL |        4 | <- GROUP BY ()
+-----------+--------------+----------+]]></text>

									<h3>CUBE() explained in SQL</h3>
									<p>
										<code>CUBE()</code> is different from <code>ROLLUP()</code> in the way that it doesn't just create <code>N+1</code> groupings, it creates all <code>2^N</code> possible combinations between all group fields in the <code>CUBE()</code> function argument list. Let's re-consider our second query from before:
									</p>

<code-pair>
<sql><![CDATA[-- CUBE() with two arguments
SELECT AUTHOR_ID, PUBLISHED_IN, COUNT(*)
FROM BOOK
GROUP BY CUBE(AUTHOR_ID, PUBLISHED_IN)










]]></sql>
<sql><![CDATA[-- The same query using UNION ALL:
  SELECT AUTHOR_ID, PUBLISHED_IN, COUNT(*) 
  FROM BOOK GROUP BY (AUTHOR_ID, PUBLISHED_IN)
UNION ALL
  SELECT AUTHOR_ID, NULL, COUNT(*) 
  FROM BOOK GROUP BY (AUTHOR_ID)
UNION ALL
  SELECT NULL, PUBLISHED_IN, COUNT(*) 
  FROM BOOK GROUP BY (PUBLISHED_IN)
UNION ALL
  SELECT NULL, NULL, COUNT(*) 
  FROM BOOK GROUP BY ()
ORDER BY 1 NULLS FIRST, 2 NULLS FIRST
]]></sql>
</code-pair>

									<p>
										The results would then hold:
									</p>

<text><![CDATA[+-----------+--------------+----------+
| AUTHOR_ID | PUBLISHED_IN | COUNT(*) |
+-----------+--------------+----------+
|      NULL |         NULL |        2 | <- GROUP BY ()
|      NULL |         1945 |        1 | <- GROUP BY (PUBLISHED_IN)
|      NULL |         1948 |        1 | <- GROUP BY (PUBLISHED_IN)
|      NULL |         1988 |        1 | <- GROUP BY (PUBLISHED_IN)
|      NULL |         1990 |        1 | <- GROUP BY (PUBLISHED_IN)
|         1 |         NULL |        2 | <- GROUP BY (AUTHOR_ID)
|         1 |         1945 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         1 |         1948 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         2 |         NULL |        2 | <- GROUP BY (AUTHOR_ID)
|         2 |         1988 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         2 |         1990 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
+-----------+--------------+----------+]]></text>

									<h3>GROUPING SETS()</h3>
									<p>
										<code>GROUPING SETS()</code> are the generalised way to create multiple groupings. From our previous examples 
									</p>
									<ul>
										<li><code>ROLLUP(AUTHOR_ID, PUBLISHED_IN)</code> corresponds to <code>GROUPING SETS((AUTHOR_ID, PUBLISHED_IN), (AUTHOR_ID), ())</code></li>
										<li><code>CUBE(AUTHOR_ID, PUBLISHED_IN)</code> corresponds to <code>GROUPING SETS((AUTHOR_ID, PUBLISHED_IN), (AUTHOR_ID), (PUBLISHED_IN), ())</code></li>
									</ul>
									<p>
										This is nicely explained in the SQL Server manual pages about <code>GROUPING SETS()</code> and other grouping functions:<br/>
										<a href="http://msdn.microsoft.com/en-us/library/bb510427(v=sql.105)">http://msdn.microsoft.com/en-us/library/bb510427(v=sql.105)</a>
									</p>
									
									<h3>jOOQ's support for ROLLUP(), CUBE(), GROUPING SETS()</h3>
									<p>
										jOOQ fully supports all of these functions, as well as the utility functions <code>GROUPING()</code> and <code>GROUPING_ID()</code>, used for identifying the grouping set ID of a record. The <reference id="factory" title="Factory API"/> thus includes:
									</p>
									
<java><![CDATA[// The various grouping function constructors
Field<?> rollup(Field<?>... fields);
Field<?> cube(Field<?>... fields);
Field<?> groupingSets(Field<?>... fields);
Field<?> groupingSets(Field<?>[]... fields);
Field<?> groupingSets(Collection<Field<?>>... fields);

// The utility functions generating IDs per GROUPING SET
Field<Integer> grouping(Field<?>);
Field<Integer> groupingId(Field<?>...);]]></java>

									<h3>MySQL's and CUBRID's WITH ROLLUP syntax</h3>
									<p>
										MySQL and CUBRID don't know any grouping functions, but they support a <code>WITH ROLLUP</code> clause, that is equivalent to simple <code>ROLLUP()</code> grouping functions. jOOQ simulates <code>ROLLUP()</code> in MySQL and CUBRID, by rendering this <code>WITH ROLLUP</code> clause. The following two statements mean the same:
									</p>
									
<code-pair>
<sql><![CDATA[-- Statement 1: SQL standard
GROUP BY ROLLUP(A, B, C)

-- Statement 2: SQL standard
GROUP BY A, ROLLUP(B, C)]]></sql>
<sql><![CDATA[-- Statement 1: MySQL
GROUP BY A, B, C WITH ROLLUP

-- Statement 2: MySQL
-- This is not supported in MySQL]]></sql>
</code-pair>
								</content>
							</section>

							<section id="user-defined-functions">
								<title>User-defined functions</title>
								<content></content>
							</section>

							<section id="user-defined-aggregate-functions">
								<title>User-defined aggregate functions</title>
								<content></content>
							</section>

							<section id="case-expressions">
								<title>The CASE expression</title>
								<content>
									<h3>The two flavours of CASE expressions</h3>
									<p>
										The CASE expression is part of the standard SQL syntax. While some RDBMS also offer an IF expression, or a DECODE function, you can always rely on the two types of CASE syntax:
									</p>

<code-pair>
<sql><![CDATA[CASE WHEN T_AUTHOR.FIRST_NAME = 'Paulo'  THEN 'brazilian'
     WHEN T_AUTHOR.FIRST_NAME = 'George' THEN 'english'
                                         ELSE 'unknown'
END

-- OR:

CASE T_AUTHOR.FIRST_NAME WHEN 'Paulo'  THEN 'brazilian'
                         WHEN 'George' THEN 'english'
                                       ELSE 'unknown'
END]]></sql>
<java><![CDATA[create.decode()
      .when(T_AUTHOR.FIRST_NAME.equal("Paulo"), "brazilian")
      .when(T_AUTHOR.FIRST_NAME.equal("George"), "english")
      .otherwise("unknown");

// OR:

create.decode().value(T_AUTHOR.FIRST_NAME)
               .when("Paulo", "brazilian")
               .when("George", "english")
               .otherwise("unknown");]]></java>
</code-pair>

								<p>
									In jOOQ, both syntaxes are supported (The second one is simulated in Derby, which only knows the first one). Unfortunately, both case and else are reserved words in Java. jOOQ chose to use decode() from the Oracle DECODE function, and otherwise(), which means the same as else.
								</p>

								<p>
									A CASE expression can be used anywhere where you can place a <reference id="column-expressions" title="column expression (or Field)"/>. For instance, you can SELECT the above expression, if you're selecting from AUTHOR:
							 	</p>

<sql>SELECT T_AUTHOR.FIRST_NAME, [... CASE EXPR ...] AS nationality
  FROM T_AUTHOR</sql>

								<h3>The Oracle DECODE() function</h3>
								<p>
									Oracle knows a more succinct, but maybe less readable DECODE() function with a variable number of arguments. This function roughly does the same as the second case expression syntax. jOOQ supports the DECODE() function and simulates it using CASE expressions in all dialects other than Oracle:
								</p>

<code-pair>
<sql><![CDATA[-- Oracle:
DECODE(FIRST_NAME, 'Paulo', 'brazilian',
                   'George', 'english',
                   'unknown');

-- Other SQL dialects
CASE T_AUTHOR.FIRST_NAME WHEN 'Paulo'  THEN 'brazilian'
                         WHEN 'George' THEN 'english'
                                       ELSE 'unknown'
END]]></sql>
<java><![CDATA[




// Use the Oracle-style DECODE() function with jOOQ.
// Note, that you will not be able to rely on type-safety
create.decode(T_AUTHOR.FIRST_NAME,
    "Paulo", "brazilian",
    "George", "english",
    "unknown");]]></java>
</code-pair>

		  							<h3>CASE clauses in an ORDER BY clause</h3>
									<p>
										Sort indirection is often implemented with a CASE clause of a SELECT's ORDER BY clause. See the manual's section about the <reference id="order-by-clause" title="ORDER BY clause"/> for more details.
									</p>
								</content>
							</section>

							<section id="sequences-and-serials">
								<title>Sequences and serials</title>
								<content>
									<h3>Sequences as a source for identity values</h3>
									<p>
										Sequences implement the <reference class="org.jooq.Sequence"/> interface, providing essentially this functionality:
									</p>

<java><![CDATA[// Get a field for the CURRVAL sequence property
Field<T> currval();

// Get a field for the NEXTVAL sequence property
Field<T> nextval();]]></java>

									<p>
										So if you have a sequence like this in Oracle:
									</p>

<sql>CREATE SEQUENCE s_author_id</sql>

									<p>
										You can then use your <reference id="codegen-sequences" title="generated sequence"/> object directly in a SQL statement as such:
									</p>

<java><![CDATA[// Reference the sequence in a SELECT statement:
BigInteger nextID = create.select(s).fetchOne(S_AUTHOR_ID.nextval());

// Reference the sequence in an INSERT statement:
create.insertInto(AUTHOR, AUTHOR.ID, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .values(S_AUTHOR_ID.nextval(), "William", "Shakespeare");
]]></java>

									<ul>
										<li>For more information about generated sequences, refer to the manual's section about <reference id="codegen-sequences" title="generated sequences"/></li>
										<li>For more information about executing standalone calls to sequences, refer to the manual's section about <reference id="sequence-execution" title="sequence execution"/></li>
									</ul>
								</content>
							</section>
						</sections>
					</section>

					<section id="conditional-expressions">
					    <title>Conditional expressions</title>
						<content></content>

						<sections>
						    <section id="condition-building">
							    <title>Condition building</title>
								<content></content>
							</section>

						    <section id="comparison-predicate">
							    <title>Comparison predicate</title>
								<content></content>
							</section>

						    <section id="null-predicate">
							    <title>NULL predicate</title>
								<content></content>
							</section>

						    <section id="distinct-predicate">
							    <title>Distinct predicate</title>
								<content></content>
							</section>

						    <section id="between-predicate">
							    <title>BETWEEN predicate</title>
								<content></content>
							</section>

						    <section id="like-predicate">
							    <title>LIKE predicate</title>
								<content></content>
							</section>

						    <section id="in-predicate">
							    <title>IN predicate</title>
								<content></content>
							</section>

						    <section id="exists-predicate">
							    <title>EXISTS predicate</title>
								<content></content>
							</section>

						    <section id="and-or-boolean-operators">
							    <title>AND, OR boolean operators</title>
								<content></content>
							</section>
						</sections>
					</section>

					<section id="plain-sql">
						<title>Plain SQL</title>
						<content>
							<h3>Plain SQL in jOOQ</h3>
							<p>
								A DSL is a nice thing to have, it feels "fluent" and "natural", especially if it models a well-known language, such as SQL. But a DSL is always expressed in a host language (Java in this case), which was not made for exactly the same purposes as its hosted DSL. If it were, then jOOQ would be implemented on a compiler-level, similar to LINQ in .NET. But it's not, and so, the DSL is limited by language constraints of its host language. We have seen many functionalities where the DSL becomes a bit verbose. This can be especially true for:
							</p>
							<ul>
								<li><reference id="aliasing" title="aliasing"/></li>
								<li><reference id="nested-selects" title="nested selects"/></li>
								<li><reference id="arithmetic-expressions" title="arithmetic expressions"/></li>
								<li><reference id="cast-expressions" title="casting"/></li>
							</ul>
							
							<p>
								You'll probably find other examples. If verbosity scares you off, don't worry. The verbose use-cases for jOOQ are rather rare, and when they come up, you do have an option. Just write SQL the way you're used to!
							</p>
							<p>
								jOOQ allows you to embed SQL as a String into any supported <reference id="sql-statements" title="statement"/> in these contexts:
							</p>
							<ul>
								<li>Plain SQL as a <reference id="conditional-expressions" title="conditional expression"/></li>
								<li>Plain SQL as a <reference id="column-expressions" title="column expression"/></li>
								<li>Plain SQL as a <reference id="column-expressions" title="function"/></li>
								<li>Plain SQL as a <reference id="table-expressions" title="table expression"/></li>
								<li>Plain SQL as a <reference id="query-vs-resultquery" title="query"/></li>
							</ul>

							<h3>The Factory plain SQL API</h3>
							<p>
								Plain SQL API methods are usually overloaded in three ways. Let's look at the <code>condition</code> query part constructor:
							</p>
<java><![CDATA[// Construct a condition without bind values
// Example: condition("a = b")
Condition condition(String sql);

// Construct a condition with bind values
// Example: condition("a = ?", 1);
Condition condition(String sql, Object... bindings);

// Construct a condition taking other jOOQ object arguments
// Example: condition("a = {0}", val(1));
Condition condition(String sql, QueryPart... parts);]]></java>
							
							<p>
								Please refer to the <reference class="org.jooq.impl.Factory"/> Javadoc for more details. The following is a more complete listing of plain SQL construction methods from the Factory:
							</p>

<java><![CDATA[// A condition
Condition condition(String sql);
Condition condition(String sql, Object... bindings);
Condition condition(String sql, QueryPart... parts);

// A field with an unknown data type
Field<Object> field(String sql);
Field<Object> field(String sql, Object... bindings);
Field<Object> field(String sql, QueryPart... parts);

// A field with a known data type
<T> Field<T> field(String sql, Class<T> type);
<T> Field<T> field(String sql, Class<T> type, Object... bindings);
<T> Field<T> field(String sql, Class<T> type, QueryPart... parts);
<T> Field<T> field(String sql, DataType<T> type);
<T> Field<T> field(String sql, DataType<T> type, Object... bindings);
<T> Field<T> field(String sql, DataType<T> type, QueryPart... parts);

// A field with a known name (properly escaped)
Field<Object> fieldByName(String... fieldName);
<T> Field<T>  fieldByName(Class<T> type, String... fieldName);
<T> Field<T>  fieldByName(DataType<T> type, String... fieldName)

// A function
<T> Field<T> function(String name, Class<T> type, Field<?>... arguments);
<T> Field<T> function(String name, DataType<T> type, Field<?>... arguments);

// A table
Table<?> table(String sql);
Table<?> table(String sql, Object... bindings);
Table<?> table(String sql, QueryPart... parts);

// A table with a known name (properly escaped)
Table<Record> tableByName(String... fieldName);

// A query without results (update, insert, etc)
Query query(String sql);
Query query(String sql, Object... bindings);
Query query(String sql, QueryPart... parts);

// A query with results
ResultQuery<Record> resultQuery(String sql);
ResultQuery<Record> resultQuery(String sql, Object... bindings);
ResultQuery<Record> resultQuery(String sql, QueryPart... parts);

// A query with results. This is the same as resultQuery(...).fetch();
Result<Record> fetch(String sql);
Result<Record> fetch(String sql, Object... bindings);
Result<Record> fetch(String sql, QueryPart... parts);]]></java>

							<p>
								Apart from the general factory methods, plain SQL is also available in various other contexts. For instance, when adding a .where("a = b") clause to a query. Hence, there exist several convenience methods where plain SQL can be inserted usefully. This is an example displaying all various use-cases in one single query:
							</p>
							
<java><![CDATA[// You can use your table aliases in plain SQL fields
// As long as that will produce syntactically correct SQL
Field<?> LAST_NAME    = create.field("a.LAST_NAME");

// You can alias your plain SQL fields
Field<?> COUNT1       = create.field("count(*) x");

// If you know a reasonable Java type for your field, you
// can also provide jOOQ with that type
Field<Integer> COUNT2 = create.field("count(*) y", Integer.class);

       // Use plain SQL as select fields
create.select(LAST_NAME, COUNT1, COUNT2)

       // Use plain SQL as aliased tables (be aware of syntax!)
      .from("t_author a")
      .join("t_book b")

       // Use plain SQL for conditions both in JOIN and WHERE clauses
      .on("a.id = b.author_id")

       // Bind a variable in plain SQL
      .where("b.title != ?", "Brida")

       // Use plain SQL again as fields in GROUP BY and ORDER BY clauses
      .groupBy(LAST_NAME)
      .orderBy(LAST_NAME);]]></java>

							<h3>Important things to note about plain SQL!</h3>
							<p>
								There are some important things to keep in mind when using plain SQL:
							</p>
							<ul>
								<li>jOOQ doesn't know what you're doing. You're on your own again!</li>
								<li>You have to provide something that will be syntactically correct. If it's not, then jOOQ won't know. Only your JDBC driver or your RDBMS will detect the syntax error.</li>
								<li>You have to provide consistency when you use variable binding. The number of ? must match the number of variables</li>
								<li>Your SQL is inserted into jOOQ queries without further checks. Hence, jOOQ can't prevent SQL injection. </li>
							</ul>
						</content>
					</section>

					<section id="bind-values">
					    <title>Bind values and parameters</title>
						<content></content>

						<sections>
						    <section id="indexed-parameters">
							    <title>Indexed parameters</title>
								<content></content>
							</section>

						    <section id="named-parameters">
							    <title>Named parameters</title>
								<content></content>
							</section>

						    <section id="inlined-parameters">
							    <title>Inlined parameters</title>
								<content></content>
							</section>

						    <section id="sql-injection-and-plain-sql-queryparts">
							    <title>SQL injection and plain SQL QueryParts</title>
								<content></content>
							</section>
						</sections>
					</section>

					<section id="queryparts">
					    <title>QueryParts</title>
						<content></content>

						<sections>
						    <section id="jooq-architecture">
							    <title>jOOQ architecture</title>
								<content></content>
							</section>

						    <section id="sql-rendering">
							    <title>SQL rendering</title>
								<content></content>
							</section>

						    <section id="variable-binding">
							    <title>Variable binding</title>
								<content></content>
							</section>

						    <section id="custom-queryparts">
							    <title>Custom QueryParts</title>
								<content></content>
							</section>

						    <section id="plain-sql-queryparts">
							    <title>Plain SQL QueryParts</title>
								<content></content>
							</section>

						    <section id="serializability">
							    <title>Serializability</title>
								<content></content>
							</section>
						</sections>
					</section>
				</sections>
			</section>

			<section id="sql-execution">
				<title>SQL execution</title>
				<content></content>

				<sections>
				    <section id="query-vs-resultquery">
						<title>Query vs. ResultQuery</title>
						<content></content>
					</section>

				    <section id="fetching">
						<title>Fetching</title>
						<content></content>

						<sections>
							<section id="record-vs-tablerecord">
								<title>Record vs. TableRecord</title>
								<content></content>
							</section>

							<section id="arrays-and-maps">
								<title>Arrays and Maps</title>
								<content></content>
							</section>

							<section id="recordhandler">
								<title>RecordHandler</title>
								<content></content>
							</section>

							<section id="pojos">
								<title>POJOs</title>
								<content></content>
							</section>

							<section id="lazy-fetching">
								<title>Lazy fetching</title>
								<content></content>
							</section>

							<section id="many-fetching">
								<title>Many fetching</title>
								<content></content>
							</section>

							<section id="resultset-fetching">
								<title>ResultSet fetching</title>
								<content></content>
							</section>

							<section id="data-type-conversion">
								<title>Data type conversion</title>
								<content></content>
							</section>
						</sections>
					</section>

				    <section id="batch-execution">
						<title>Batch execution</title>
						<content></content>
					</section>

				    <section id="sequence-execution">
						<title>Sequence execution</title>
						<content></content>
					</section>

				    <section id="stored-procedures">
						<title>Stored procedures and functions</title>
						<content></content>

						<sections>
							<section id="oracle-packages">
								<title>Oracle Packages</title>
								<content></content>
							</section>

							<section id="oracle-member-procedures">
								<title>Oracle user-defined types and member procedures</title>
								<content></content>
							</section>
						</sections>
					</section>

				    <section id="exporting">
						<title>Exporting to XML, CSV, JSON, HTML, Text</title>
						<content>
							<h3>Exporting with jOOQ</h3>
							<p>
								If you are using jOOQ for scripting purposes or in a slim, unlayered application server, you might be interested in using jOOQ's exporting functionality (see also the <reference id="importing" title="importing functionality"/>). You can export any Result&lt;Record&gt; into the formats discussed in the subsequent chapters of the manual
							</p>
						</content>

						<sections>
							<section id="exporting-xml">
								<title>Exporting XML</title>
								<content>
									<h3>Export your results as XML</h3>

<java>// Fetch books and format them as XML
String xml = create.selectFrom(BOOK).fetch().formatXML();</java>

									<p>
										The above query will result in an XML document looking like the following one:
									</p>

<xml><![CDATA[<result xmlns="http://www.jooq.org/xsd/jooq-export-1.6.2.xsd">
  <fields>
    <field name="ID"/>
    <field name="AUTHOR_ID"/>
    <field name="TITLE"/>
  </fields>
  <records>
    <record>
      <value field="ID">1</value>
      <value field="AUTHOR_ID">1</value>
      <value field="TITLE">1984</value>
    </record>
    <record>
      <value field="ID">2</value>
      <value field="AUTHOR_ID">1</value>
      <value field="TITLE">Animal Farm</value>
    </record>
  </records>
</result>]]></xml>

									<p>
										The same result as an <reference class="org.w3c.dom.Document"/> can be obtained using the Result.intoXML() method:
									</p>


<java>// Fetch books and format them as XML
Document xml = create.selectFrom(BOOK).fetch().intoXML();</java>

									<p>
										See the XSD schema definition here, for a formal definition of the XML export format:<br/>
										<a href="http://www.jooq.org/xsd/jooq-export-1.6.2.xsd">http://www.jooq.org/xsd/jooq-export-1.6.2.xsd</a>
									</p>
								</content>
							</section>

							<section id="exporting-csv">
								<title>Exporting CSV</title>
								<content>
									<h3>Export your results as CSV</h3>

<java>// Fetch books and format them as CSV
String csv = create.selectFrom(BOOK).fetch().formatCSV();</java>

									<p>
										The above query will result in a CSV document looking like the following one:
									</p>

<text>ID,AUTHOR_ID,TITLE
1,1,1984
2,1,Animal Farm</text>

									<p>
										In addition to the standard behaviour, you can also specify a separator character, as well as a special string to represent NULL values (which cannot be represented in standard CSV):
									</p>

<java>// Use ";" as the separator character
String csv = create.selectFrom(BOOK).fetch().formatCSV(';');

// Specify "{null}" as a representation for NULL values
String csv = create.selectFrom(BOOK).fetch().formatCSV(';', "{null}");</java>

								</content>
							</section>

							<section id="exporting-json">
								<title>Exporting JSON</title>
								<content>
									<h3>Export your results as JSON</h3>

<java>// Fetch books and format them as JSON
String json = create.selectFrom(BOOK).fetch().formatJSON();</java>

									<p>
										The above query will result in a JSON document looking like the following one:
									</p>

<text>{fields:["ID","AUTHOR_ID","TITLE"],
 records:[[1,1,"1984"],[2,1,"Animal Farm"]]}</text>
								</content>
							</section>

							<section id="exporting-html">
								<title>Exporting HTML</title>
								<content>
 									<h3>Export your results as HTML</h3>
<java>// Fetch books and format them as HTML
String html = create.selectFrom(BOOK).fetch().formatHTML();</java>

									<p>
										The above query will result in an HTML document looking like the following one
									</p>

<xml><![CDATA[<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>AUTHOR_ID</th>
      <th>TITLE</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1984</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1</td>
      <td>Animal Farm</td>
    </tr>
  </tbody>
</table>]]></xml>

								</content>
							</section>

							<section id="exporting-text">
								<title>Exporting Text</title>
								<content>
									<h3>Export your results as text</h3>

<java>// Fetch books and format them as text
String text = create.selectFrom(BOOK).fetch().format();</java>

									<p>
										The above query will result in a text document looking like the following one
									</p>

<text>+---+---------+-----------+
| ID|AUTHOR_ID|TITLE      |
+---+---------+-----------+
|  1|        1|1984       |
|  2|        1|Animal Farm|
+---+---------+-----------+</text>

									<p>
										A simple text representation can also be obtained by calling toString() on a Result object. See also the manual's section about <reference id="logging" title="DEBUG logging"/>
									</p>
								</content>
							</section>
						</sections>
					</section>

				    <section id="importing">
						<title>Importing data</title>
						<content>
							<h3>Importing data into your database using jOOQ</h3>
							<p>
								If you are using jOOQ for scripting purposes or in a slim, unlayered application server, you might be interested in using jOOQ's importing functionality (see also exporting functionality). You can import data directly into a table from the formats described in the subsequent sections of this manual.
							</p>
						</content>

						<sections>
							<section id="importing-csv">
								<title>Importing CSV</title>
								<content>
									<h3>Importing CSV with jOOQ</h3>

									<p>
										The below CSV data represents two author records that may have been exported previously, by jOOQ's <reference id="exporting" title="exporting functionality"/>, and then modified in Microsoft Excel or any other spreadsheet tool:
									</p>

<text>ID;AUTHOR_ID;TITLE
1;1;1984
2;1;Animal Farm</text>

									<p>
										With jOOQ, you can load this data using various parameters from the	loader API. A simple load may look like this:
									</p>

<java>Factory create = new Factory(connection, dialect);

// Load data into the AUTHOR table from an input stream
// holding the CSV data.
create.loadInto(AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, AUTHOR_ID, TITLE)
      .execute();</java>

      								<p>
      									Here are various other examples:
   									</p>

<java>// Ignore the AUTHOR_ID column from the CSV file when inserting
create.loadInto(AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour for duplicate records.
create.loadInto(AUTHOR)

      // choose any of these methods
      .onDuplicateKeyUpdate()
      .onDuplicateKeyIgnore()
      .onDuplicateKeyError() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour when errors occur.
create.loadInto(AUTHOR)

      // choose any of these methods
      .onErrorIgnore()
      .onErrorAbort() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify transactional behaviour where this is possible
// (e.g. not in container-managed transactions)
create.loadInto(AUTHOR)

      // choose any of these methods
      .commitEach()
      .commitAfter(10)
      .commitAll()
      .commitNone() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();</java>

									<p>
										Any of the above configuration methods can be combined to achieve the type of load you need. Please refer to the API's Javadoc to learn about more details. Errors that occur during the load are reported by the execute method's result:
									</p>

<java><![CDATA[Loader<Author> loader = /* .. */ .execute();

// The number of processed rows
int processed = loader.processed();

// The number of stored rows (INSERT or UPDATE)
int stored = loader.stored();

// The number of ignored rows (due to errors, or duplicate rule)
int ignored = loader.ignored();

// The errors that may have occurred during loading
List<LoaderError> errors = loader.errors();
LoaderError error = errors.get(0);

// The exception that caused the error
DataAccessException exception = error.exception();

// The row that caused the error
int rowIndex = error.rowIndex();
String[] row = error.row();

// The query that caused the error
Query query = error.query();]]></java>

								</content>
							</section>

							<section id="importing-xml">
								<title>XML</title>
								<content>
									<h3>Importing XML into jOOQ</h3>
									<p>This is not yet supported</p>
								</content>
							</section>
						</sections>
					</section>

				    <section id="crud-with-updatablerecords">
						<title>CRUD with UpdatableRecords</title>
						<content></content>

						<sections>
							<section id="simple-crud">
								<title>Simple CRUD</title>
								<content></content>
							</section>

							<section id="non-updatable-records">
								<title>Non-updatable records</title>
								<content></content>
							</section>

							<section id="optimistic-locking">
								<title>Optimistic locking</title>
								<content></content>
							</section>

							<section id="batch-execution-for-crud">
								<title>Batch execution</title>
								<content></content>
							</section>
						</sections>
					</section>

				    <section id="daos">
						<title>DAOs</title>
						<content></content>
					</section>

				    <section id="execute-listeners">
						<title>ExecuteListeners</title>
						<content></content>
					</section>

				    <section id="logging">
						<title>Logging</title>
						<content></content>
					</section>

				    <section id="performance-considerations">
						<title>Performance considerations</title>
						<content></content>
					</section>
				</sections>
			</section>

			<section id="code-generation">
				<title>Code generation</title>
				<content></content>

				<sections>
				    <section id="codegen-configuration">
						<title>Configuration</title>
						<content></content>
					</section>

				    <section id="codegen-advanced">
						<title>Advanced Configuration</title>
						<content></content>
					</section>

				    <section id="codegen-globals">
						<title>Generated global artefacts</title>
						<content></content>
					</section>

				    <section id="codegen-tables">
						<title>Generated tables</title>
						<content></content>
					</section>

				    <section id="codegen-sequences">
						<title>Generated sequences</title>
						<content></content>
					</section>

				    <section id="codegen-procedures">
						<title>Generated tables</title>
						<content></content>
					</section>

				    <section id="master-data-types">
						<title>Master data and enumeration tables</title>
						<content></content>
					</section>

				    <section id="custom-data-types">
						<title>Custom data types and type conversions</title>
						<content></content>
					</section>

				    <section id="schema-mapping">
						<title>Schema mapping</title>
						<content></content>
					</section>
				</sections>
			</section>

			<section id="tools">
				<title>Tools</title>
				<content></content>

				<sections>
					<section id="jooq-console">
						<title>jOOQ Console</title>
						<content></content>

						<sections>
							<section id="jooq-console-logger">
								<title>Logger</title>
								<content></content>
							</section>

							<section id="jooq-console-debugger">
								<title>Debugger</title>
								<content></content>
							</section>

							<section id="jooq-console-editor">
								<title>Editor</title>
								<content></content>
							</section>
						</sections>
					</section>
				</sections>
			</section>

			<section id="reference">
				<title>Reference</title>
				<content></content>

				<sections>
					<section id="supported-rdbms">
						<title>Supported RDBMS</title>
						<content></content>
					</section>

					<section id="reference-data-types">
						<title>Data types</title>
						<content></content>
					</section>

					<section id="reference-functions">
						<title>Functions</title>
						<content></content>
					</section>

					<section id="reference-bnf-notation">
						<title>jOOQ's BNF pseudo-notation</title>
						<content></content>
					</section>

					<section id="reference-glossary">
						<title>Glossary</title>
						<content></content>
					</section>
				</sections>
			</section>
		</sections>
	</section>
</manual>